<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>尹枭凌</title>
 <link href="http://yinxiaoling.github.io/atom.xml" rel="self"/>
 <link href="http://yinxiaoling.github.io/"/>
 <updated>2015-08-07T00:13:00+08:00</updated>
 <id>http://yinxiaoling.github.io</id>
 <author>
   <name>尹枭凌</name>
   <email>350231275@qq.com</email>
 </author>

 
 <entry>
   <title>Git — Git常用命令速查表</title>
   <link href="http://yinxiaoling.github.io/git/2015/08/06/Git-Git-command/"/>
   <updated>2015-08-06T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/git/2015/08/06/Git-Git-command</id>
   <content type="html">&lt;h4&gt;master: 默认开发分支&lt;/h4&gt;

&lt;h4&gt;origin: 默认远程版本库&lt;/h4&gt;

&lt;h4&gt;Head: 默认开发分支&lt;/h4&gt;

&lt;h4&gt;Head^: Head的父提交&lt;/h4&gt;

&lt;hr&gt;

&lt;h2&gt;创建版本库&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#克隆远程版本库&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;init&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;#初始化本地版本库&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修改和提交&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;status&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#查看状态&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;diff&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;#查看变更内容&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;#跟踪所有改动过的文件&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;#跟踪指定的文件&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;old&amp;gt;&amp;lt;new&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#文件改名&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rm&amp;lt;file&amp;gt;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#删除文件&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cached&amp;lt;file&amp;gt;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;#停止跟踪文件但不删除&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;commit&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;messages&amp;quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#提交所有更新过的文件&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--amend&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;#修改最后一次改动&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;查看提交历史&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;log&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;#查看提交历史&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;#查看指定文件的提交历史&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;blame&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;#以列表方式查看指定文件的提交历史&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;撤销&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;reset&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--hard&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;HEAD&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#撤销工作目录中所有未提交文件的修改内容&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;checkout&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;HEAD&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#撤销指定的未提交文件的修改内容&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;revert&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;commit&amp;gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#撤销指定的提交&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--before=&amp;quot;1&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;days&amp;quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#退回到之前1天的版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;分支与标签&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;branch&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;#显示所有本地分支&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;checkout&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch/tag&amp;gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;#切换到指定分支和标签&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;branch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;new-branch&amp;gt;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#创建新分支&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;branch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch&amp;gt;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;#删除本地分支&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tag&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;#列出所有本地标签&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;tagname&amp;gt;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;#基于最新提交创建标签&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;tagname&amp;gt;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;#删除标签&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;合并与衍合&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;merge&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch&amp;gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#合并指定分支到当前分支&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rebase&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch&amp;gt;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;#衍合指定分支到当前分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;远程操作&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-Nginx&quot; data-lang=&quot;Nginx&quot;&gt;    &lt;span class=&quot;k&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;remote&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;-v&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;#查看远程版本库信息&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;remote&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#查看指定远程版本库信息&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;remote&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#添加远程版本库&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;fetch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;#从远程库获取代码&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;pull&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch&amp;gt;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#下载代码及快速合并&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;branch&amp;gt;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#上传代码及快速合并&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;remote&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;branch/tag-name&amp;gt;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#删除远程分支或标签&lt;/span&gt;
    $ &lt;span class=&quot;s&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--tags&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;#上传所有标签&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Others — 让你此生难成大器的七宗罪</title>
   <link href="http://yinxiaoling.github.io/others/2015/08/01/other-qizongzui/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/others/2015/08/01/other-qizongzui</id>
   <content type="html">&lt;h4&gt;1. Because You Have Not Failed Enough&lt;/h4&gt;

&lt;h4&gt;第一宗罪：你失败得还不够。&lt;/h4&gt;

&lt;p&gt;Because you are comfortable in your mediocrity; because you choose not to try.&lt;/p&gt;

&lt;p&gt;因为你满足于平庸，因为你选择不去尝试。&lt;/p&gt;

&lt;p&gt;Because it is easier to talk about learning that new (programming?) language as opposed to actually learning it.&lt;/p&gt;

&lt;p&gt;因为只在嘴上说说学习一门新外语(或编程)比真正去学容易太多。&lt;/p&gt;

&lt;p&gt;Because you think everything is too hard or too complicated so you will just “sit this one out”, or maybe you’ll, “do-it-tomorrow”!&lt;/p&gt;

&lt;p&gt;因为在你看来，每件事都“太难”或者“太复杂”，所以你选择“等等看吧“或者”明天再做好了“。&lt;/p&gt;

&lt;p&gt;Because you hate your job but won’t get a new one; because it is easy to reject rejection.&lt;/p&gt;

&lt;p&gt;即便你讨厌自己的工作，也不愿意换另一份，因为你觉得自己可以轻易拒绝”被拒绝“这件事。&lt;/p&gt;

&lt;p&gt;Because while you’re sitting around failing to try, I am out there trying to fail, challenging myself, learning new things and failing as fast as possible.&lt;/p&gt;

&lt;p&gt;但就在你一事无成、败于尝试之际，我正在尝试各种可能、哪怕失败，我正在挑战自我、学习新知识、如果失败，那么越早越好。&lt;/p&gt;

&lt;h4&gt;2. Because You Care What Others Think About You&lt;/h4&gt;

&lt;h4&gt;第二宗罪：你在乎别人对你的看法。&lt;/h4&gt;

&lt;p&gt;Because you have to fit in.&lt;/p&gt;

&lt;p&gt;因为你要合群。&lt;/p&gt;

&lt;p&gt;Because you believe that being different is only cool if you’re different in the same way that other people are different.&lt;/p&gt;

&lt;p&gt;因为你坚信，与众不同的你，要跟大众一起用同样的方法与众不同，才算酷。&lt;/p&gt;

&lt;p&gt;Because you are afraid to embrace your true self for fear of how the world will see you.&lt;/p&gt;

&lt;p&gt;因为你害怕面对真正的自己，因为你害怕世界会对你另眼相看。&lt;/p&gt;

&lt;p&gt;Because while you’re out spending your money on new outfits, new cars, overpriced meals or nights at the bar, I’ll be investing in myself. And while you try to fit in with the world I’ll make the world fit in with me.&lt;/p&gt;

&lt;p&gt;但当你在不断买新衣、新车、光顾昂贵餐厅和各色酒吧之时，我正在不断投资自己。你在不断努力求得主流认可，而我将让主流认可我。&lt;/p&gt;

&lt;p&gt;Because I will recklessly abandon all insecurities and expose my true self to the world. I will become immune to the impact of your opinion and stand naked in a crowd of ideas; comfortable in knowing that while you married the mundane I explored the exceptional.&lt;/p&gt;

&lt;p&gt;我会一窝蜂抛掉所有不安全感，让世界看见真正的我。你怎么看我，我不再在乎。我会只身受信念大潮的冲洗，怡然自得地看你与世俗联姻，而我却与超凡携手。&lt;/p&gt;

&lt;h4&gt;3. Because You Think You Are Smarter Than You Are&lt;/h4&gt;

&lt;h4&gt;第三宗罪：因为你自觉十分聪明。&lt;/h4&gt;

&lt;p&gt;Because you did what everyone else did; you studied what they studied and read what they read.&lt;/p&gt;

&lt;p&gt;因为别人干什么你就干什么，别人学什么你就学什么，别人读什么书你也依葫芦画瓢读同一本。&lt;/p&gt;

&lt;p&gt;Because you learned what you had to learn in order to pass their tests and you think that makes you smart.&lt;/p&gt;

&lt;p&gt;因为你学习是为了通过考试，通过既定的考试又让你觉得自己很聪明。&lt;/p&gt;

&lt;p&gt;Because while you were away at college, I was studying life; because instead of learning about the world in a classroom I went out and learned it by living.&lt;/p&gt;

&lt;p&gt;但你读大学的时候，我正在学习人生；我选择不在教室里学习这个世界，而是真正闯进去，活在真实世界里，以此为我的课堂。&lt;/p&gt;

&lt;p&gt;Because I know more than any piece of paper you could ever frame from a university. Because smart is not what you learn, it’s how you live.&lt;/p&gt;

&lt;p&gt;因为我懂得的，远比任何一张文凭赋予的都多。因为聪明从来都不是学来的，聪明是从生活中来的。&lt;/p&gt;

&lt;p&gt;Tests that are not graded on a bell curve or by percentages; tests that are graded by one simple stipulation: survival!&lt;/p&gt;

&lt;p&gt;生活的考试，从不依据什么贝尔曲线、通过率来评分，生活的考试有且仅有那么一条评分依据：生存！&lt;/p&gt;

&lt;h4&gt;4. Because You Don’t Read&lt;/h4&gt;

&lt;h4&gt;第四宗罪：你从不读书。&lt;/h4&gt;

&lt;p&gt;Because you read the things you are required to read or nothing at all.&lt;/p&gt;

&lt;p&gt;因为你要么就是读些必读的书，要么就是根本连读都不读。&lt;/p&gt;

&lt;p&gt;Because you think history is boring and philosophy is stupid.&lt;/p&gt;

&lt;p&gt;因为你觉得历史枯燥无味，哲学更是愚蠢可笑。&lt;/p&gt;

&lt;p&gt;Because you would rather sit and watch “E!” or “MTV” instead of exploring something new, instead of diving head first, into the brain of another man in an attempt to better understand the world around you.&lt;/p&gt;

&lt;p&gt;因为你宁可坐在那看八卦新闻、音乐台，也不愿意去学点新东西，不愿一头扎进其他人的思想里去更好地了解这个世界。&lt;/p&gt;

&lt;p&gt;Because you refuse to acknowledge that all the power in the world comes from the words of those that lived before us. That anything you desire can be had by searching through the multitude of words that are available to us now more abundantly than ever before.&lt;/p&gt;

&lt;p&gt;你不愿承认，世界上所有的力量都源自先人的思想。你不愿承认你想要的所有东西，都能从那前人无数的思想里寻获，且在当下，寻获这些信息是前所未有的便捷。&lt;/p&gt;

&lt;h4&gt;5. Because You Lack Curiosity&lt;/h4&gt;

&lt;h4&gt;第五宗罪：你毫无好奇心。&lt;/h4&gt;

&lt;p&gt;Because you get your news from copy-cat members of the state-controlled media.&lt;/p&gt;

&lt;p&gt;因为就连你看的新闻，也全是从政府掌控的媒体上来的。&lt;/p&gt;

&lt;p&gt;Because you are unwilling to ask this simple question… “What if it’s all a lie?”, and accept the possibility that maybe it is; that just maybe, the methods of mass media are under direct orders to: keep you distracted.&lt;/p&gt;

&lt;p&gt;因为你连“如果这些全是假的怎么办？”这么简单的问题都不愿意问，更别说接受如此假设成真的可能了，或许，主流媒体都是言听计从混淆大众的呢。&lt;/p&gt;

&lt;p&gt;Because you call me a know-it-all but refuse to call yourself a know-nothing-at-all.&lt;/p&gt;

&lt;p&gt;你说我“自以为无所不知”，却不肯承认自己一无所知。&lt;/p&gt;

&lt;p&gt;Because I thirst for knowledge, regardless the topic.&lt;/p&gt;

&lt;p&gt;我渴望知识，任何知识。&lt;/p&gt;

&lt;p&gt;Because while you waste your time with Tosh.o I am learning how to edit video, build websites and design mobile apps.&lt;/p&gt;

&lt;p&gt;因为你在看连续剧，我却在学习怎么编辑视频、建立网站和开发手机应用。&lt;/p&gt;

&lt;h4&gt;6. Because You Don’t Ask Enough Questions&lt;/h4&gt;

&lt;h4&gt;第六宗罪：因为你问得太少。&lt;/h4&gt;

&lt;p&gt;Because you do not question authority.&lt;/p&gt;

&lt;p&gt;因为你从不质问权威。&lt;/p&gt;

&lt;p&gt;Because you don’t question yourself.&lt;/p&gt;

&lt;p&gt;因为你从不质问自己。&lt;/p&gt;

&lt;p&gt;Because you don’t understand the power of properly placed questioning in life, respectful disagreements and standing up for what you know to be right in the face of someone telling you otherwise. Unable to question reality; stuck in a self imposed survival strategy within a matrix-style monotony.&lt;/p&gt;

&lt;p&gt;因为你不明白正确的问题在生活中有着怎样的意义、你不懂礼貌的反对和在与自己意见相悖的人面前捍卫自己正确观点的力量几何。不能真正提出疑问，无疑等于被困在自我欺骗的牢笼里，以此为生存策略。&lt;/p&gt;

&lt;h4&gt;7. Because You Can’t Handle The Truth&lt;/h4&gt;

&lt;h4&gt;第七宗罪：因为你不能直面真相&lt;/h4&gt;

&lt;p&gt;Because you refuse to admit that you don’t even know the things you don’t know.&lt;/p&gt;

&lt;p&gt;因为你不愿承认你不懂的事情，你是真的不懂。&lt;/p&gt;

&lt;p&gt;Because even if I told you everything could be different tomorrow you would wait until then to begin doing anything about it.&lt;/p&gt;

&lt;p&gt;因为就算我告诉你，明天一切都会改变，你也会等到明天才开始行动。&lt;/p&gt;

&lt;p&gt;You walk around with your head up your ass, oblivious to the world around you. Blissfully ignorant of the reality that sits so close to your face that if you stuck your tongue out, just once, you would taste it and realize how delicious the truth actually is.&lt;/p&gt;

&lt;p&gt;你埋头前行，对世界不闻不问。你满心欢喜地忽略就在眼前的真相，可是真相那么近，你只要探出舌头那么一次，就能尝到它的滋味，它美妙的滋味。&lt;/p&gt;

&lt;p&gt;Because you would become an instant addict. Unable to pull yourself from the teat of truth. Finally able to understand your lack of understanding, and then you would see; then you would know that the only thing holding you back from doing something truly amazing, is you.&lt;/p&gt;

&lt;p&gt;因为你会欲罢不能，无法将自己从真相的怀抱里拔出。最后你会明白你还未学会理解，然后你会发现，然后你会明白，让你止步不前难成大器的，只有你自己。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — Java程序员应该掌握的十项技能</title>
   <link href="http://yinxiaoling.github.io/java/2015/08/01/other-PG-10jineng/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/08/01/other-PG-10jineng</id>
   <content type="html">&lt;h3&gt;1、语法：必须比较熟悉，在写代码的时候IDE的编辑器对某一行报错应该能够根据报错信息知道是什么样的语法错误并且知道任何修正。&lt;/h3&gt;

&lt;h3&gt;2、命令：必须熟悉JDK带的一些常用命令及其常用选项，命令至少需要熟悉：appletviewer、 HtmlConverter、jar、 java、javac、javadoc、javap、javaw、native2ascii、serialver，如果这些命令你没有全部使用过，那么你对java实际上还很不了解。&lt;/h3&gt;

&lt;h3&gt;3、工具：必须至少熟练使用一种IDE的开发工具，例如Eclipse、Netbeans、JBuilder、Jdeveloper、IDEA、JCreator或者Workshop，包括进行工程管理、常用选项的设置、插件的安装配置以及进行调试。&lt;/h3&gt;

&lt;h3&gt;4、API：Java的核心API是非常庞大的，但是有一些内容笔者认为是必须熟悉的，否则不可能熟练的运用Java，包括：&lt;/h3&gt;

&lt;h3&gt;◆java.lang包下的80％以上的类的功能的灵活运用。&lt;/h3&gt;

&lt;h3&gt;◆java.util包下的80％以上的类的灵活运用，特别是集合类体系、规则表达式、zip、以及时间、随机数、属性、资源和Timer.&lt;/h3&gt;

&lt;h3&gt;◆java.io包下的60％以上的类的使用，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。&lt;/h3&gt;

&lt;h3&gt;◆java.math包下的100％的内容。&lt;/h3&gt;

&lt;h3&gt;◆java.net包下的60％以上的内容，对各个类的功能比较熟悉。&lt;/h3&gt;

&lt;h3&gt;◆java.text包下的60％以上的内容，特别是各种格式化类。&lt;/h3&gt;

&lt;h3&gt;◆熟练运用JDBC）、java.security包下40％以上的内容，如果对于安全没有接触的话根本就不可能掌握java.&lt;/h3&gt;

&lt;h3&gt;◆AWT的基本内容，包括各种组件事件、监听器、布局管理器、常用组件、打印。&lt;/h3&gt;

&lt;h3&gt;◆Swing的基本内容，和AWT的要求类似。&lt;/h3&gt;

&lt;h3&gt;◆XML处理，熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理。&lt;/h3&gt;

&lt;h3&gt;5、测试：必须熟悉使用junit编写测试用例完成代码的自动测试。&lt;/h3&gt;

&lt;h3&gt;6、管理：必须熟悉使用ant完成工程管理的常用任务，例如工程编译、生成javadoc、生成jar、版本控制、自动测试。&lt;/h3&gt;

&lt;h3&gt;7、排错：应该可以根据异常信息比较快速的定位问题的原因和大致位置。&lt;/h3&gt;

&lt;h3&gt;8、思想：必须掌握OOP的主要要求，这样使用Java开发的系统才能是真正的Java系统。&lt;/h3&gt;

&lt;h3&gt;9、规范：编写的代码必须符合流行的编码规范，例如类名首字母大写，成员和方法名首字母小写，方法名的第一个单词一般是动词，包名全部小写等，这样程序的可读性才比较好。&lt;/h3&gt;

&lt;h3&gt;10、博学：掌握J2EE 、Oracle 、WebLogic、Jboss、Spring、Struts、Hibernate 等流行技术，掌握软件架构设计思想、搜索引擎优化、缓存系统设计、网站负载均衡、系统性能调优等实用技术。&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery — jQuery操作select</title>
   <link href="http://yinxiaoling.github.io/jquery/2015/08/01/jQuery-caozuo-select/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/jquery/2015/08/01/jQuery-caozuo-select</id>
   <content type="html">&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jQuery获取Select选择的Text和Value:

语法解释：

1. $(&amp;quot;#select_id&amp;quot;).change(function(){//code...});   //为Select添加事件，当选择其中一项时触发
2. var checkText=$(&amp;quot;#select_id&amp;quot;).find(&amp;quot;option:selected&amp;quot;).text();  //获取Select选择的Text
3. var checkValue=$(&amp;quot;#select_id&amp;quot;).val();  //获取Select选择的Value
4. var checkIndex=$(&amp;quot;#select_id &amp;quot;).get(0).selectedIndex;  //获取Select选择的索引值
5. var maxIndex=$(&amp;quot;#select_id option:last&amp;quot;).attr(&amp;quot;index&amp;quot;);  //获取Select最大的索引值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jQuery设置Select选择的 Text和Value:

语法解释：

    1. $(&amp;quot;#select_id &amp;quot;).get(0).selectedIndex=1;  //设置Select索引值为1的项选中
    2. $(&amp;quot;#select_id &amp;quot;).val(4);   // 设置Select的Value值为4的项选中
    3. $(&amp;quot;#select_id option[text=&amp;#39;jQuery&amp;#39;]&amp;quot;).attr(&amp;quot;selected&amp;quot;, true);   //设置Select的Text值为jQuery的项选中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jQuery添加/删除Select的Option项：

语法解释：

    1. $(&amp;quot;#select_id&amp;quot;).append(&amp;quot;&amp;lt;option value=&amp;#39;Value&amp;#39;&amp;gt;Text&amp;lt;/option&amp;gt;&amp;quot;);  //为Select追加一个Option(下拉项)
    2. $(&amp;quot;#select_id&amp;quot;).prepend(&amp;quot;&amp;lt;option value=&amp;#39;0&amp;#39;&amp;gt;请选择&amp;lt;/option&amp;gt;&amp;quot;);  //为Select插入一个Option(第一个位置)
    3. $(&amp;quot;#select_id option:last&amp;quot;).remove();  //删除Select中索引值最大Option(最后一个)
    4. $(&amp;quot;#select_id option[index=&amp;#39;0&amp;#39;]&amp;quot;).remove();  //删除Select中索引值为0的Option(第一个)
    5. $(&amp;quot;#select_id option[value=&amp;#39;3&amp;#39;]&amp;quot;).remove();  //删除Select中Value=&amp;#39;3&amp;#39;的Option
    5. $(&amp;quot;#select_id option[text=&amp;#39;4&amp;#39;]&amp;quot;).remove();  //删除Select中Text=&amp;#39;4&amp;#39;的Option
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jquery radio取值，checkbox取值，select取值，radio选中，checkbox选中，select选中，及其相关获取一组radio被选中项的值 

    var item = $(&amp;#39;input[name=items][checked]&amp;#39;).val();

获 取select被选中项的文本 

    var item = $(&amp;quot;select[name=items] option[selected]&amp;quot;).text(); 

select下拉框的第二个元素为当前选中值 

    $(&amp;#39;#select_id&amp;#39;)[0].selectedIndex = 1; 

radio单选组的第二个元素为当前选中值 

    $(&amp;#39;input[name=items]&amp;#39;).get(1).checked = true; 


获取值： 

    文本框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;)； 
    多选框 checkbox：$(&amp;quot;#checkbox_id&amp;quot;).attr(&amp;quot;value&amp;quot;)； 
    单选组radio：   $(&amp;quot;input[type=radio][checked]&amp;quot;).val(); 
    下拉框select： $(&amp;#39;#sel&amp;#39;).val();

控制表单元素： 

    文本框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;&amp;#39;);//清空内容 
    $(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;11&amp;#39;);//填充内容 
    多选框checkbox： $(&amp;quot;#chk1&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;&amp;#39;);//不打勾 
    $(&amp;quot;#chk2&amp;quot;).attr(&amp;quot;checked&amp;quot;,true);//打勾 
    if($(&amp;quot;#chk1&amp;quot;).attr(&amp;#39;checked&amp;#39;)==undefined) //判断是否已经打勾 
    单选组 radio：    $(&amp;quot;input[type=radio]&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;2&amp;#39;);//设置value=2的项目为当前选中项 
    下拉框 select：   $(&amp;quot;#sel&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;-sel3&amp;#39;);//设置value=-sel3的项目为当前选中项 
    $(&amp;quot;&amp;lt;option value=&amp;#39;1&amp;#39;&amp;gt;1111&amp;lt;/option&amp;gt;&amp;lt;option value=&amp;#39;2&amp;#39;&amp;gt;2222&amp;lt;/option&amp;gt;&amp;quot;).appendTo(&amp;quot;#sel&amp;quot;)//添加下拉框的option 
    $(&amp;quot;#sel&amp;quot;).empty()；//清空下拉框
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    //遍历option和添加、移除option
    function changeShipMethod(shipping){
        var len = $(&amp;quot;select[name=ISHIPTYPE] option&amp;quot;).length
        if(shipping.value != &amp;quot;CA&amp;quot;){
            $(&amp;quot;select[name=ISHIPTYPE] option&amp;quot;).each(function(){
                if($(this).val() == 111){
                    $(this).remove();
                }
            });
        }else{
            $(&amp;quot;&amp;lt;option value=&amp;#39;111&amp;#39;&amp;gt;UPS Ground&amp;lt;/option&amp;gt;&amp;quot;).appendTo($(&amp;quot;select[name=ISHIPTYPE]&amp;quot;));`
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//取得下拉選單的選取值

    $(#testSelect option:selected&amp;#39;).text();
或
    $(&amp;quot;#testSelect&amp;quot;).find(&amp;#39;option:selected&amp;#39;).text();
或
    $(&amp;quot;#testSelect&amp;quot;).val();

1,下拉框:

    var cc1 = $(&amp;quot;.formc select[name=&amp;#39;country&amp;#39;] option[selected]&amp;quot;).text(); //得到下拉菜单的选中项的文本(注意中间有空格)
    var cc2 = $(&amp;#39;.formc select[name=&amp;quot;country&amp;quot;]&amp;#39;).val(); //得到下拉菜单的选中项的值
    var cc3 = $(&amp;#39;.formc select[name=&amp;quot;country&amp;quot;]&amp;#39;).attr(&amp;quot;id&amp;quot;); //得到下拉菜单的选中项的ID属性值
    $(&amp;quot;#select&amp;quot;).empty();//清空下拉框 //$(&amp;quot;#select&amp;quot;).html(&amp;#39;&amp;#39;);
    $(&amp;quot;&amp;lt;option value=&amp;#39;1&amp;#39;&amp;gt;1111&amp;lt;/option&amp;gt;&amp;quot;).appendTo(&amp;quot;#select&amp;quot;)//添加下拉框的option

解释:
    1.select[name=&amp;#39;country&amp;#39;] option[selected] 表示具有name 属性，
    并 且该属性值为&amp;#39;country&amp;#39; 的select元素 里面的具有selected 属性的option 元素；

2,单选框:
    $(&amp;quot;input[@type=radio][@checked]&amp;quot;).val(); //得到单选框的 选中项的值(注意中间没有空格)
    $(&amp;quot;input[@type=radio][@value=2]&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;checked&amp;#39;); //设置单选框value=2的为选中状态.(注意中间没有空格)

3,复选框:
    $(&amp;quot;input[@type=checkbox][@checked]&amp;quot;).val(); //得到复选框的选中的第一项的值
    $(&amp;quot;input[@type=checkbox][@checked]&amp;quot;).each(function() { //由于复选框一般选中的是多个,所以可以循环输出
        alert($(this).val());
    });

    $(&amp;quot;#chk1&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;&amp;#39;);//不打勾
    $(&amp;quot;#chk2&amp;quot;).attr(&amp;quot;checked&amp;quot;,true);// 打勾
    if($(&amp;quot;#chk1&amp;quot;).attr(&amp;#39;checked&amp;#39;)==undefined){} //判断是否已经打勾
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;当然jquery的选择器是强大的. 还有很多方法.

    &amp;lt;script src=&amp;quot;jquery-1.2.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $(document).ready(function(){
            $(&amp;quot;#selectTest&amp;quot;).change(function(){
                //alert(&amp;quot;Hello&amp;quot;);
                //alert($(&amp;quot;#selectTest&amp;quot;).attr(&amp;quot;name&amp;quot;));
                //$(&amp;quot;a&amp;quot;).attr(&amp;quot;href&amp;quot;,&amp;quot;xx.html&amp;quot;);
                //window.location.href=&amp;quot;xx.html&amp;quot;;
                //alert($(&amp;quot;#selectTest&amp;quot;).val());
                alert($(&amp;quot;#selectTest option[@selected]&amp;quot;).text());
                $(&amp;quot;#selectTest&amp;quot;).attr(&amp;quot;value&amp;quot;, &amp;quot;2&amp;quot;);
            });
        });
    &amp;lt;/script&amp;gt;`

    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;aaass&amp;lt;/a&amp;gt;

&amp;lt;!--下拉框--&amp;gt;
    &amp;lt;select id=&amp;quot;selectTest&amp;quot; name=&amp;quot;selectTest&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;11&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;22&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;3&amp;quot;&amp;gt;33&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;4&amp;quot;&amp;gt;44&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;5&amp;quot;&amp;gt;55&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;6&amp;quot;&amp;gt;66&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jquery radio取值，checkbox取值，select取值，radio选中，checkbox选中，select选中，及其相关获取一组radio被选中项的值

    var item = $(&amp;#39;input[@name=items][@checked]&amp;#39;).val();

获取select被选 中项的文本

    var item = $(&amp;quot;select[@name=items] option[@selected]&amp;quot;).text();

select 下拉框的第二个元素为当前选中值

    $(&amp;#39;#select_id&amp;#39;)[0].selectedIndex = 1;

radio单选组的第二个 元素为当前选中值

    $(&amp;#39;input[@name=items]&amp;#39;).get(1).checked = true;

获取值：

    文本 框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;)；
    多选框 checkbox：$(&amp;quot;#checkbox_id&amp;quot;).attr(&amp;quot;value&amp;quot;)；
    单选组radio： $(&amp;quot;input[@type=radio][@checked]&amp;quot;).val();
    下拉框select： $(&amp;#39;#sel&amp;#39;).val();

控 制表单元素：

    文本框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;&amp;#39;);//清空内容
    $(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;11&amp;#39;);// 填充内容
    多选框checkbox： $(&amp;quot;#chk1&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;&amp;#39;);//不打勾
    $(&amp;quot;#chk2&amp;quot;).attr(&amp;quot;checked&amp;quot;,true);// 打勾
    if($(&amp;quot;#chk1&amp;quot;).attr(&amp;#39;checked&amp;#39;)==undefined) //判断是否已经打勾
    单选组radio： $(&amp;quot;input[@type=radio]&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;2&amp;#39;);//设置value=2的项目为当前选中项
    下拉框 select： $(&amp;quot;#sel&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;-sel3&amp;#39;);//设置value=-sel3的项目为当前选中项
    $(&amp;quot;&amp;lt;optionvalue=&amp;#39;1&amp;#39;&amp;amp; gt;1111&amp;lt;/option&amp;gt;&amp;lt;optionvalue=&amp;#39;2&amp;#39;&amp;gt;2222&amp;lt;/option&amp;amp; gt;&amp;quot;).appendTo(&amp;quot;#sel&amp;quot;)//添加下拉框的option
    $(&amp;quot;#sel&amp;quot;).empty()；// 清空下拉框

获取一组radio被选中项的值

    var item = $(&amp;#39;input[@name=items][@checked]&amp;#39;).val();

获取select被选中项的文本

    var item = $(&amp;quot;select[@name=items] option[@selected]&amp;quot;).text();

select下拉框的第二个元素为当 前选中值

    $(&amp;#39;#select_id&amp;#39;)[0].selectedIndex = 1;

radio单选组的第二个元素为当前选中值

    $(&amp;#39;input[@name=items]&amp;#39;).get(1).checked = true;

获取值：

    文本框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;)；
    多选框 checkbox：$(&amp;quot;#checkbox_id&amp;quot;).attr(&amp;quot;value&amp;quot;)；
    单选组radio： $(&amp;quot;input[@type=radio][@checked]&amp;quot;).val();
    下拉框select： $(&amp;#39;#sel&amp;#39;).val();

控 制表单元素：

    文本框，文本区域：$(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;&amp;#39;);//清空内容
    $(&amp;quot;#txt&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;11&amp;#39;);// 填充内容
    多选框checkbox： $(&amp;quot;#chk1&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;&amp;#39;);//不打勾
    $(&amp;quot;#chk2&amp;quot;).attr(&amp;quot;checked&amp;quot;,true);// 打勾
    if($(&amp;quot;#chk1&amp;quot;).attr(&amp;#39;checked&amp;#39;)==undefined) //判断是否已经打勾
    单选组radio： $(&amp;quot;input[@type=radio]&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;#39;2&amp;#39;);//设置value=2的项目为当前选中项
    下拉框 select： $(&amp;quot;#sel&amp;quot;).attr(&amp;quot;value&amp;quot;,&amp;#39;-sel3&amp;#39;);//设置value=-sel3的项目为当前选中项
    $(&amp;quot;&amp;lt;option value=&amp;#39;1&amp;#39;&amp;gt;1111&amp;lt;/option&amp;gt;&amp;lt;option value=&amp;#39;2&amp;#39;&amp;gt;2222&amp;lt;/option&amp;gt;&amp;quot;).appendTo(&amp;quot;#sel&amp;quot;)//添加下拉框的option
    $(&amp;quot;#sel&amp;quot;).empty()；// 清空下拉框
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>SQL — SQL性能优化</title>
   <link href="http://yinxiaoling.github.io/sql/2015/08/01/SQL-SQL-Performance-Optimization/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/sql/2015/08/01/SQL-SQL-Performance-Optimization</id>
   <content type="html">&lt;h6&gt;1.不论一个SQL中涉及到多个表，每次都用两个表（结果集）操作，得到新的结果后，再和下一个表（结果集）操作。&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;2.避免在select column1，（select column2 from tableB）...form tableA;这样得到字段列，直接使用A/B关联得到column1和2就可以。&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;3.避免隐含类型转换&lt;/h6&gt;

&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emp_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emp_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：emp_id是整数型，用&amp;#39;8&amp;#39;会默认启动类型转换，增加查询的开销。&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;4.尽量减少使用正则表达式，尽量不使用通配符&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;5.使用关键字代替函数&lt;/h6&gt;

&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPPER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;TECH_DB&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUBSTR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;TECH&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dept&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;TECH%&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里还要说一点，除非业务硬性要求，模糊查询尽量使用前方一致。不要使用‘%%’这样的空字符串进行查询。&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;6.不要在字段上使用转换函数，尽量在常量上使用&lt;/h6&gt;

&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;yyyy-mm-dd&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;2012-10-31&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create_date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;2012-10-31&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;yyyy-mm-dd&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;7.不使用连接（||）做查询&lt;/h6&gt;

&lt;p&gt;例：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;Jo%&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;8.不要对字段进行运算&lt;/h6&gt;

&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creat_date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;2012-10-31&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;yyyy-mm-dd&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creat_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;2012-10-31&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;yyyy-mm-dd&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外强调一点：在WHERE 语句中，尽量避免对索引字段进行计算操作&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;9.使用exists代替in，使用not exists 代替 not in&lt;/h6&gt;

&lt;p&gt;用IN写出来的SQL的优点是比较容易写及清晰易懂，这比较适合现代软件开发的风格。&lt;/p&gt;

&lt;p&gt;但是用IN的SQL性能总是比较低的，从ORACLE执行的步骤来分析用IN的SQL与不用IN的SQL有以下区别：&lt;/p&gt;

&lt;p&gt;ORACLE试图将其转换成多个表的连接，如果转换不成功则先执行IN里面的子查询，再查询外层的表记录，如果转换成功则直接采用多个表的连接方式查询。由此可见用IN的SQL至少多了一个转换的过程。一般的SQL都可以转换成功，但对于含有分组统计等方面的SQL就不能转换了。&lt;/p&gt;

&lt;p&gt;NOT IN操作符:此操作是强列推荐不使用的，因为它不能应用表的索引。&lt;/p&gt;

&lt;p&gt;推荐方案：用NOT EXISTS 或(外连接+判断为空)方案代替
例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_level&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;....)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;X&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_level&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;....)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;10.索引类型&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;唯一索引，对于查询用到的字段，尽可能使用唯一索引。&lt;/li&gt;
&lt;li&gt;还有一些其他类型，如位图索引，在性别字段，只有男女的字段上用。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h6&gt;11.在经常进行连接，但是没有指定为外键的列上建立索引&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;12.在频繁进行排序会分组的列上建立索引，如经常做group by 或 order by 操作的字段&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;13.在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不建立索引&lt;/h6&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;p&gt;性别列上只有男，女两个不同的值，就没必要建立索引（或建立位图索引）。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;14.在值比较少的字段做order by时，翻页会出现记录紊乱问题，要带上id字段一起做order by&lt;/h6&gt;

&lt;hr&gt;

&lt;h6&gt;15.*是禁止的&lt;/h6&gt;

&lt;p&gt;在应用程序、包和过程中限制使用select * from table这种方式。看下面例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;7369&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要使用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;7369&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;16.&amp;lt;&amp;gt; 操作符(不等于)&lt;/h6&gt;

&lt;p&gt;不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。&lt;/p&gt;

&lt;p&gt;推荐方案：用其它相同功能的操作运算代替，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;改为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;改为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;17.IS NULL 或IS NOT NULL操作(判断字段是否为空)&lt;/h6&gt;

&lt;p&gt;判断字段是否为空一般是不会应用索引的，因为B树索引是不索引空值的。&lt;/p&gt;

&lt;p&gt;推荐方案：&lt;/p&gt;

&lt;p&gt;用其它相同功能的操作运算代替，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;改为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;或&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;等。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不允许字段为空，而用一个缺省值代替空值，如业扩申请中状态字段不允许为空，缺省为申请。&lt;/p&gt;

&lt;p&gt;建立位图索引(有分区的表不能建，位图索引比较难控制，如字段值太多索引会使性能下降，多人更新操作会增加数据块锁的现象)&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;18.&amp;gt; 及 &amp;lt; 操作符(大于或小于操作符)&lt;/h6&gt;

&lt;p&gt;大于或小于操作符一般情况下是不用调整的，因为它有索引就会采用索引查找，但有的情况下可以对它进行优化，如一个表有100万记录，一个数值型字段A，30万记录的A=0，30万记录的A=1，39万记录的A=2，1万记录的A=3。&lt;/p&gt;

&lt;p&gt;那么执行A&amp;gt;2与A&amp;gt;=3的效果就有很大的区别了，因为A&amp;gt;2时ORACLE会先找出为2的记录索引再进行比较，而A&amp;gt;=3时ORACLE则直接找到=3的记录索引。&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;19.LIKE操作符&lt;/h6&gt;

&lt;p&gt;LIKE操作符可以应用通配符查询，里面的通配符组合可能达到几乎是任意的查询，但是如果用得不好则会产生性能上的问题，如&lt;code&gt;LIKE ‘%5400%’&lt;/code&gt; 这种查询不会引用索引，而&lt;code&gt;LIKE ‘X5400%’&lt;/code&gt;则会引用范围索引。&lt;/p&gt;

&lt;p&gt;一个实际例子：用YW&lt;em&gt;YHJBQK表中营业编号后面的户标识号可来查询营业编号 `YY&lt;/em&gt;BH LIKE &amp;#39;%5400%&amp;#39;` 这个条件会产生全表扫描，如果改成&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;YY_BH LIKE &amp;#39;X5400%&amp;#39; OR YY_BH LIKE &amp;#39;B5400%&amp;#39; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则会利用YY_BH的索引进行两个范围的查询，性能肯定大大提高。&lt;/p&gt;

&lt;p&gt;尽量避免在一个复杂查询里面使用 &lt;code&gt;LIKE &amp;#39;%parm1%&amp;#39;&lt;/code&gt;—— 会导致相关列的索引无法使用，最好不要用.&lt;/p&gt;

&lt;p&gt;解决办法:&lt;/p&gt;

&lt;p&gt;其实只需要对该脚本略做改进，查询速度便会提高近百倍。改进方法如下：&lt;/p&gt;

&lt;p&gt;a、修改前台程序——把查询条件的供应商名称一栏由原来的文本输入改为下拉列表，用户模糊输入供应商名称时，直接在前台就帮忙定位到具体的供应商，这样在调用后台程序时，这列就可以直接用等于来关联了。&lt;/p&gt;

&lt;p&gt;b、直接修改后台——根据输入条件，先查出符合条件的供应商，并把相关记录保存在一个临时表里头，然后再用临时表去做复杂关联&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;20.索引问题&lt;/h6&gt;

&lt;p&gt;在做性能跟踪分析过程中，经常发现有不少后台程序的性能问题是因为缺少合适索引造成的，有些表甚至一个索引都没有。这种情况往往都是因为在设计表时，没去定义索引，而开发初期，由于表记录很少，索引创建与否，可能对性能没啥影响，开发人员因此也未多加重视。然一旦程序发布到生产环境，随着时间的推移，表记录越来越多&lt;/p&gt;

&lt;p&gt;这时缺少索引，对性能的影响便会越来越大了。&lt;/p&gt;

&lt;p&gt;这个问题需要数据库设计人员和开发人员共同关注&lt;/p&gt;

&lt;p&gt;法则：不要在建立的索引的数据列上进行下列操作:&lt;/p&gt;

&lt;p&gt;◆避免对索引字段进行计算操作&lt;/p&gt;

&lt;p&gt;◆避免在索引字段上使用&lt;code&gt;not，&amp;lt;&amp;gt;，!=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;◆避免在索引列上使用&lt;code&gt;IS NULL和IS NOT NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;◆避免在索引列上出现数据类型转换&lt;/p&gt;

&lt;p&gt;◆避免在索引字段上使用函数&lt;/p&gt;

&lt;p&gt;◆避免建立索引的列中使用空值。&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;21.复杂操作&lt;/h6&gt;

&lt;p&gt;部分&lt;code&gt;UPDATE、SELECT&lt;/code&gt; 语句 写得很复杂（经常嵌套多级子查询）——可以考虑适当拆成几步，先生成一些临时数据表，再进行关联操作&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;22.UPDATE&lt;/h6&gt;

&lt;p&gt;同一个表的修改在一个过程里出现好几十次，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这类脚本可以整合在一个&lt;code&gt;UPDATE&lt;/code&gt;语句来完成.&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;23.在可以使用UNION ALL的语句里，使用了UNION&lt;/h6&gt;

&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt; 因为会将各查询子集的记录做比较，故比起&lt;code&gt;UNION ALL&lt;/code&gt; ，通常速度都会慢上许多。&lt;/p&gt;

&lt;p&gt;一般来说，如果使用&lt;code&gt;UNION ALL&lt;/code&gt;能满足要求的话，务必使用&lt;code&gt;UNION ALL&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有一种情况大家可能会忽略掉，就是虽然要求几个子集的并集需要过滤掉重复记录，但由于脚本的特殊性，不可能存在重复记录，这时便应该使用&lt;code&gt;UNION ALL&lt;/code&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;24.1.避免在WHERE子句中使用&lt;code&gt;in，not  in，or&lt;/code&gt;或者&lt;code&gt;having&lt;/code&gt;。&lt;/h6&gt;

&lt;p&gt;可以使用 &lt;code&gt;exist&lt;/code&gt;和&lt;code&gt;not exist&lt;/code&gt;代替 &lt;code&gt;in&lt;/code&gt;和&lt;code&gt;not in&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可以使用表链接代替 &lt;code&gt;exist&lt;/code&gt;。&lt;code&gt;Having&lt;/code&gt;可以用&lt;code&gt;where&lt;/code&gt;代替，如果无法代替可以分两步处理。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ORDERS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER_NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER_NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ORDERS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER_NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exist&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER_NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CUSTOMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;24.2.不要以字符格式声明数字，要以数字格式声明字符值。（日期同样）否则会使索引无效，产生全表扫描。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7369&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要使用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;7369&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h6&gt;25.排序&lt;/h6&gt;

&lt;p&gt;避免使用耗费资源的操作，带有&lt;code&gt;DISTINCT,UNION,MINUS,INTERSECT,ORDER BY&lt;/code&gt;的SQL语句会启动SQL引擎执行，耗费资源的排序(SORT)功能. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;DISTINCT&lt;/code&gt;需要一次排序操作, 而其他的至少需要执行两次排序.&lt;/p&gt;

&lt;hr&gt;

&lt;h6&gt;26.临时表&lt;/h6&gt;

&lt;p&gt;慎重使用临时表可以极大的提高系统性能.&lt;/p&gt;

&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Log4j — Log4j日志输出到数据库</title>
   <link href="http://yinxiaoling.github.io/log4j/2015/08/01/Log4j-Log4j-output-to-database/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/log4j/2015/08/01/Log4j-Log4j-output-to-database</id>
   <content type="html">&lt;h6&gt;log4j是一个优秀的开源日志记录项目，我们不仅可以对输出的日志的格式自定义，还可以自己定义日志输出的目的地，比如：屏幕，文本文件，数据库，甚至能通过socket输出。&lt;/h6&gt;

&lt;h6&gt;用log4j将日志写入数据库主要用到是log4j包下的JDBCAppender类，它提供了将日志信息异步写入数据的功能，我们可以直接使用这个类将我们的日志信息写入数据库；也可以扩展JDBCAppender类，就是将JDBCAppender类作为基类。下面将通过一个实例来讲解log4j是如何将日志信息写入数据库的。&lt;/h6&gt;

&lt;h6&gt;需求：我们在软件开发的过程中需要将调试信息、操作信息等记录下来，以便后面的审计，这些日志信息包括用户ID、用户姓名、操作类、路径、方法、操作时间、日志信息。&lt;/h6&gt;

&lt;h6&gt;设计思想：我们采用JDBCAppender类直接将日志信息插入数据库，所有只需要在配置文件配置此类就可以;要获得用户信息需要用过滤器来实现；（假如不需要用户的信息，就不需要设计过滤器，其实大部分情况下都是需要这些用户信息，尤其是在web应用开发中）在日志信息中获得用户信息，就的通过过滤器的request或session对象，从session中拿到用户信息怎样传到log4j呢，log4j为我们提供了MDC（MDC是log4j种非常有用类，它们用于存储应用程序的上下文信息（context infomation），从而便于在log中使用这些上下文信息。MDC内部使用了类似map的机制来存储信息，上下文信息也是每个线程独立地储存，所不同的是信息都是以它们的key值存储在”map”中。相对应的方法，MDC.put(key, value); MDC.remove(key); MDC.get(key);在配置PatternLayout的时候使用：%x{key}来输出对应的value）。有了MDC，我们可以在过滤器中先获得用户信息，再用MDC.Put（“key”）方法，log在执行sql语句时通过%x{key}来输出对应的value。&lt;/h6&gt;

&lt;h6&gt;1.确保有log4j和commons-logging这两个jar包，然后创建表结构(本例数据库是mysql)：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `log_logger`
-- ----------------------------
DROP TABLE IF EXISTS `log_logger`;
CREATE TABLE `log_logger` (
  `id` bigint(255) NOT NULL AUTO_INCREMENT COMMENT &amp;#39;自增主键&amp;#39;,
  `level` varchar(255) DEFAULT NULL COMMENT &amp;#39;优先级&amp;#39;,
  `category` varchar(255) DEFAULT NULL COMMENT &amp;#39;类目&amp;#39;,
  `thread` varchar(255) DEFAULT NULL COMMENT &amp;#39;进程&amp;#39;,
  `time` varchar(30) DEFAULT NULL COMMENT &amp;#39;时间&amp;#39;,
  `location` varchar(255) DEFAULT NULL COMMENT &amp;#39;位置&amp;#39;,
  `note` text COMMENT &amp;#39;日志信息&amp;#39;,
  `ip` varchar(255) DEFAULT NULL COMMENT &amp;#39;IP地址&amp;#39;,
  `userId` varchar(255) DEFAULT NULL COMMENT &amp;#39;操作员&amp;#39;,
  `userName` varchar(255) DEFAULT NULL COMMENT &amp;#39;操作员姓名&amp;#39;,
  PRIMARY KEY (`id`),
  KEY `FK8448DAEB47AA554A` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;2.配置log4j.properties文件&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log4j.rootLogger=WARN,ROLLING

#应用于控制台
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.Threshold=WARN
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=[start][OPEN][%d{yyyy-MM-dd HH:mm:ss,SSS}][%p][%t][%c][%m][end]%n

#分包控制
log4j.logger.com.tjopen=WARN,CONSOLE

#分层控制
log4j.logger.com.tjopen.base.dao=WARN,BaseDao,db
log4j.logger.com.tjopen.define.business=WARN,BizBusiness,db
log4j.logger.com.tjopen.define.action=WARN,action,db

#应用于分层控制的BaseBusiness
#此处省略

#应用于分层控制的BizBusiness
#此处省略

#应用于分层控制的action
#此处省略

#应用于文件回滚
#此处省略

# 应用于数据库
log4j.appender.db=org.apache.log4j.jdbc.JDBCAppender
#设置缓存大小，就是当有10条日志信息时才输入数据库一次
log4j.appender.db.BufferSize=10
log4j.appender.db.URL=jdbc:mysql://192.168.1.177:3306/openbase
#设置要将日志插入到数据库的驱动
log4j.appender.db.driver=com.mysql.jdbc.Driver
log4j.appender.db.user=root
log4j.appender.db.password=1234
log4j.appender.db.layout=org.apache.log4j.PatternLayout
log4j.appender.db.sql=INSERT INTO log_logger(time,level,thread,category,note,location,ip,userId,userName) VALUES(&amp;#39;%d{yyyy-MM-dd HH\:mm\:ss,SSS}&amp;#39;,&amp;#39;%p&amp;#39;,&amp;#39;%t&amp;#39;,&amp;#39;%c&amp;#39;,&amp;#39;%m&amp;#39;,&amp;#39;%l&amp;#39;,&amp;#39;%X{ip}&amp;#39;,&amp;#39;%X{userId}&amp;#39;,&amp;#39;%X{userName}&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;配置文件中加入上边的代码(&amp;#39;%X{ip}&amp;#39;,&amp;#39;%X{userId}&amp;#39;,&amp;#39;%X{userName}&amp;#39;取得我们设置在MDC中的值;&amp;#39;%C&amp;#39;表示日志信息是来自于那个类；%M表示日志信息来自于那个方法中；%d{yyyy-MM-dd HH:mm:ss}表示日志信息产生的时间，{yyyy-MM-dd HH:mm:ss}表示一种时间格式，你也可以直接写成%d；%p表示日志信息的级别（debug info warn error）；%m表示你写入的日志信息)。&lt;/h6&gt;

&lt;h6&gt;3.编写一个过滤器用于获取自定义的IP地址、用户ID、用户名称。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.log4j.MDC;

import com.tjopen.authority.pojo.AcOperator;

/**
 * &amp;lt;b&amp;gt;类名称：&amp;lt;/b&amp;gt;UserFilter&amp;lt;br/&amp;gt;
 * &amp;lt;b&amp;gt;类描述：&amp;lt;/b&amp;gt;记录当前操作员信息到log4j.MDC &amp;lt;br/&amp;gt;
 * &amp;lt;b&amp;gt;创建人：&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;
 * &amp;lt;b&amp;gt;修改人：&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;
 * &amp;lt;b&amp;gt;修改时间：&amp;lt;/b&amp;gt;2013-6-14 下午1:23:15&amp;lt;br/&amp;gt;
 * &amp;lt;b&amp;gt;修改备注：&amp;lt;/b&amp;gt;&amp;lt;br/&amp;gt;
 * 
 * @version 1.0.0&amp;lt;br/&amp;gt;
 */
public class UserFilter implements Filter {

    private final static double DEFAULT_USERID = Math.random() * 100000.0;

    @Override
    public void destroy() {
        // TODO Auto-generated method stub
    }

    /*
     * 获取操作员名称
     * 
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,
     * javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpSession session = req.getSession();
        MDC.put(&amp;quot;ip&amp;quot;, req.getRemoteAddr());
        if (session != null) {
            AcOperator loginOperator = (AcOperator) session
                    .getAttribute(&amp;quot;acOperator&amp;quot;);
            if (loginOperator != null &amp;amp;&amp;amp; loginOperator.getOperatorid() != null
                    &amp;amp;&amp;amp; loginOperator.getOmEmployee().getEmpname() != null
                    &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(loginOperator.getOperatorid())
                    &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(loginOperator.getOmEmployee().getEmpname())) {
                MDC.put(&amp;quot;userId&amp;quot;, loginOperator.getOperatorid());
                MDC.put(&amp;quot;userName&amp;quot;, loginOperator.getOmEmployee().getEmpname());
            } else {
                MDC.put(&amp;quot;userId&amp;quot;, DEFAULT_USERID);
                MDC.put(&amp;quot;userName&amp;quot;, DEFAULT_USERID);
            }
        } else {
            MDC.put(&amp;quot;userId&amp;quot;, DEFAULT_USERID);
            MDC.put(&amp;quot;userName&amp;quot;, DEFAULT_USERID);
        }
        chain.doFilter(request, response);
    }

    @Override
    public void init(FilterConfig arg0) throws ServletException {
        // TODO Auto-generated method stub
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;4.在web.xml文件中配置自定义的过滤器：&lt;/h6&gt;

&lt;h6&gt;在struts2的核心过滤器之前加入自定义的过滤器。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!-- 记录操作员信息的过滤器(用于log4j的MDC) --&amp;gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;UserFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;
        com.tjopen.base.util.UserFilter
    &amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;UserFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

&amp;lt;!-- struts configration --&amp;gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.FilterDispatcher&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;5.在需要写入日志的地方引入&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private Log logger = LogFactory.getLog(this.getClass()); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;在具体方法中就可以写入日志&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;logger.info(&amp;quot;&amp;quot;);  
logger.debug(&amp;quot;&amp;quot;);  
logger.warn(&amp;quot;&amp;quot;);  
logger.error(&amp;quot;&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Linux命令—traceroute、tracepath</title>
   <link href="http://yinxiaoling.github.io/linux/2015/08/01/Linux-Linux-command-traceroute-tracepath/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/linux/2015/08/01/Linux-Linux-command-traceroute-tracepath</id>
   <content type="html">&lt;h3&gt;windows之tracert与linux之traceroute用法详解&lt;/h3&gt;

&lt;p&gt;通过Traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。&lt;/p&gt;

&lt;p&gt;当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。&lt;/p&gt;

&lt;p&gt;UNIX系统中，我们称之为Traceroute,MS Windows中为Tracert。 &lt;/p&gt;

&lt;p&gt;Traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备Traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。&lt;/p&gt;

&lt;p&gt;在大多数情况下，作为网络工程技术人员或者系统管理员会在UNIX主机系统下，直接执行命令行（注意目前新一代的Linux系统许多用&lt;code&gt;tracepath&lt;/code&gt;命令，用法类似）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Traceroute hostname 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在Windows系统下是执行Tracert的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Tracerert hostname
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;windows之tracert&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;C:\&amp;gt;tracert 

Usage: tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，&lt;code&gt;Tracert&lt;/code&gt;可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 &lt;code&gt;tracert&lt;/code&gt;无效。&lt;/p&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;p&gt;-d
指定不对计算机名解析地址。&lt;/p&gt;

&lt;p&gt;-h maximum_hops
指定查找目标的跳转的最大数目。&lt;/p&gt;

&lt;p&gt;-jcomputer-list
指定在 computer-list 中松散源路由。&lt;/p&gt;

&lt;p&gt;-w timeout
等待由 timeout 对每个应答指定的毫秒数。&lt;/p&gt;

&lt;p&gt;target_name
目标计算机的名称。&lt;/p&gt;

&lt;h2&gt;linux之traceroute&lt;/h2&gt;

&lt;p&gt;Traceroute的命令参数：&lt;/p&gt;

&lt;p&gt;Traceroute的用法为: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Traceroute [options] &amp;lt;IP-address or domain-name&amp;gt; [data size]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[options]的内容有:&lt;/p&gt;

&lt;p&gt;-d   使用Socket层级的排错功能。&lt;/p&gt;

&lt;p&gt;-f&amp;lt;存活数值&amp;gt;   设置第一个检测数据包的存活数值TTL的大小。&lt;/p&gt;

&lt;p&gt;-F   设置勿离断位。&lt;/p&gt;

&lt;p&gt;-g&amp;lt;网关&amp;gt;   设置来源路由网关，最多可设置8个。&lt;/p&gt;

&lt;p&gt;-i&amp;lt;网络界面&amp;gt;   使用指定的网络界面送出数据包。&lt;/p&gt;

&lt;p&gt;-I   使用ICMP回应取代UDP资料信息。&lt;/p&gt;

&lt;p&gt;-m&amp;lt;存活数值&amp;gt;   设置检测数据包的最大存活数值TTL的大小。&lt;/p&gt;

&lt;p&gt;-n   直接使用IP地址而非主机名称。&lt;/p&gt;

&lt;p&gt;-p&amp;lt;通信端口&amp;gt;   设置UDP传输协议的通信端口。(缺省为33434)&lt;/p&gt;

&lt;p&gt;-q  设置TTL测试数目(缺省为3)&lt;/p&gt;

&lt;p&gt;-r   忽略普通的Routing Table，直接将数据包送到远端主机上。&lt;/p&gt;

&lt;p&gt;-s&amp;lt;来源地址&amp;gt;   设置本地主机送出数据包的IP地址。&lt;/p&gt;

&lt;p&gt;-t&amp;lt;服务类型&amp;gt;   设置检测数据包的TOS数值。&lt;/p&gt;

&lt;p&gt;-v   详细显示指令的执行过程。&lt;/p&gt;

&lt;p&gt;-w&amp;lt;超时秒数&amp;gt;   设置等待远端主机回报的时间。&lt;/p&gt;

&lt;p&gt;-x   开启或关闭数据包的正确性检验。  &lt;/p&gt;

&lt;h2&gt;Traceroute的工作原理：&lt;/h2&gt;

&lt;p&gt;Traceroute最简单的基本用法是：&lt;code&gt;traceroute hostname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。&lt;/p&gt;

&lt;p&gt;首先，&lt;code&gt;traceroute&lt;/code&gt;送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），&lt;code&gt;traceroute&lt;/code&gt;收到这个消息后，便知道这个路由器存在于这个路径上，接着&lt;code&gt;traceroute&lt;/code&gt;再送出另一个TTL是2 的datagram，发现第2 个路由器...... &lt;code&gt;traceroute&lt;/code&gt;每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么&lt;code&gt;traceroute&lt;/code&gt;如何得知目的地到达了呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Traceroute&lt;/code&gt;在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当&lt;code&gt;traceroute&lt;/code&gt;收到这个消息时，便知道目的地已经到达了。所以&lt;code&gt;traceroute&lt;/code&gt;在Server端也是没有所谓的Daemon 程式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Traceroute&lt;/code&gt;提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，&lt;code&gt;Traceroute&lt;/code&gt;都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。&lt;/p&gt;

&lt;p&gt;转自&lt;a href=&quot;http://yp.oss.org.cn/software/show_resource.php?resource_id=1057&quot;&gt;开源黄页&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux命令—ssh</title>
   <link href="http://yinxiaoling.github.io/linux/2015/08/01/Linux-Linux-command-ssh/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/linux/2015/08/01/Linux-Linux-command-ssh</id>
   <content type="html">&lt;blockquote&gt;
&lt;p&gt;ssh常见客户端用法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]    

[-D [bind_address:]port] [-e escape_char] [-F configfile]    

[-I pkcs11] [-i identity_file]    

[-L [bind_address:]port:host:hostport]    

[-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]    

[-R [bind_address:]port:host:hostport] [-S ctl_path]    

[-W host:port] [-w local_tun[:remote_tun]]    

[user@]hostname [command]    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常见参数：&lt;/p&gt;

&lt;p&gt;-D: 绑定本地端口&lt;/p&gt;

&lt;p&gt;-F: 指定config文件的位置&lt;/p&gt;

&lt;p&gt;-l: 登录用户名&lt;/p&gt;

&lt;p&gt;-p: 远程端口&lt;/p&gt;

&lt;p&gt;-N: 只转发端口，不执行远程命令，proxy时的常用参数&lt;/p&gt;

&lt;p&gt;-i: key的解密文件路径，通常指~/.ssh/id&lt;em&gt;rsa ~/.ssh/id&lt;/em&gt;ecdsa ~/.ssh/id_dsa&lt;/p&gt;

&lt;p&gt;-C: 压缩传输&lt;/p&gt;

&lt;p&gt;-c: 选择用于加密连接的加密方式&lt;/p&gt;

&lt;p&gt;-1: 只使用protocol 1连接&lt;/p&gt;

&lt;p&gt;-2: 只使用protocol 2链接&lt;/p&gt;

&lt;p&gt;-4: 只使用ipv4链接&lt;/p&gt;

&lt;p&gt;-6: 只使用ipv6链接&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;普通登录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ssh user@remotehost    

or    

ssh -l user remotehost    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;proxy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ssh -C -N -D localport username@hostname -p remoteport    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在本地localport端口建立到remotehost的ssh链接，不执行远程命令，并压缩传输&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;mount&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sshfs -p remoteport user@localhost:/remotepath localpath    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将远程主机的remotepath挂载到本地localpath&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;umount&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fusermount -u localpath    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;卸载挂载文件&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;upload&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;scp localpath/file user@localhost:/remotepath    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传本地file到远程的remotepath&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;download&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;scp username@localhost:/remotepath/file localpath    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载远程file文件到本地&lt;/p&gt;

&lt;p&gt;一般而言，对于常用参数，我们将之写入到.ssh/config文件中是个很常用的做法&lt;/p&gt;

&lt;p&gt;Host name
    HostName    ip
    port    21
    User    havanna
Compression yes&lt;/p&gt;

&lt;p&gt;如此，连接时如下即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ssh name    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Javascript — 解决URL传值时的中文乱码问题</title>
   <link href="http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-zhongwenluanmawenti/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-zhongwenluanmawenti</id>
   <content type="html">&lt;h2&gt;传递参数的页面对中文进行编码&lt;/h2&gt;

&lt;p&gt;js对文字进行编码涉及3个函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;escape,encodeURI,encodeURIComponent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相 应 3 个 解 码 函 数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unescape,decodeURI,decodeURIComponent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;1、传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。&lt;/h6&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;document.write(&amp;#39;&amp;lt;a href=&amp;quot;http://passport.baidu.com/?logout&amp;amp;aid=7&amp;amp; u=&amp;#39;+encodeURIComponent(&amp;quot;http://cang.baidu.com/bruce42&amp;quot;)+&amp;#39;&amp;quot;&amp;gt;退出&amp;lt;/a&amp;amp; gt;&amp;#39;);&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;2、进行url跳转时可以整体使用encodeURI&lt;/h6&gt;

&lt;p&gt;例如： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Location.href=encodeURI(http://cang.baidu.com/do/s?word=中国&amp;amp;ct=21);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这个方法编码的字符在PHP中可以使用urldecode()函数反编码&lt;/p&gt;

&lt;h6&gt;3、js使用数据时可以使用escape&lt;/h6&gt;

&lt;p&gt;escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。&lt;/p&gt;

&lt;p&gt;escape不编码字符有69个：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; *，+，-，.，/，@，_，0-9，a-z，A-Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;encodeURI不编码字符有82个：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;!，#，$，&amp;amp;，&amp;#39;，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;encodeURIComponent不编码字符有71个：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;!， &amp;#39;，(，)，*，-，.，_，~，0-9，a-z，A-Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;介绍:&lt;/p&gt;

&lt;p&gt;escape方法&lt;/p&gt;

&lt;p&gt;对String对象编码以便它们能在所有计算机上可读，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;escape(charString)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;必选项 charstring 参数是要编码的任意 String 对象或文字。&lt;/p&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;p&gt;escape方法返回一个包含了 charstring 内容的字符串值（ Unicode 格式）。所有空格、标点、重音符号以及其他非 ASCII 字符都用 %xx 编码代替，&lt;/p&gt;

&lt;p&gt;其中 xx 等于表示该字符的十六进制数。例如，空格返回的是 &amp;quot;%20&amp;quot; 。&lt;/p&gt;

&lt;p&gt;字符值大于 255 的以 %uxxxx 格式存储。&lt;/p&gt;

&lt;p&gt;注意   escape 方法不能够用来对统一资源标示码 (URI) 进行编码。对其编码应使用 encodeURI 和encodeURIComponent 方法。&lt;/p&gt;

&lt;p&gt;encodeURI 方法&lt;/p&gt;

&lt;p&gt;将文本字符串编码为一个有效的统一资源标识符 (URI)。&lt;/p&gt;

&lt;p&gt;encodeURI(URIString)
必选的 URIString 参数代表一个已编码的 URI。&lt;/p&gt;

&lt;p&gt;说明
    encodeURI 方法返回一个编码的 URI。如果您将编码结果传递给 decodeURI，那么将返回初始的字符串。encodeURI 方法不会对下列字符进行编码：&amp;quot;:&amp;quot;、&lt;/p&gt;

&lt;p&gt;&amp;quot;/&amp;quot;、&amp;quot;;&amp;quot; 和 &amp;quot;?&amp;quot;。请使用 encodeURIComponent 方法对这些字符进行编码。&lt;/p&gt;

&lt;p&gt;encodeURIComponent 方法&lt;/p&gt;

&lt;p&gt;将文本字符串编码为一个统一资源标识符 (URI) 的一个有效组件。&lt;/p&gt;

&lt;p&gt;encodeURIComponent(encodedURIString)
必选的 encodedURIString 参数代表一个已编码的 URI 组件。&lt;/p&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;p&gt;encodeURIComponent 方法返回一个已编码的 URI。如果您将编码结果传递给 decodeURIComponent，那么将返回初始的字符串。因为 encodeURIComponent&lt;/p&gt;

&lt;p&gt;方法对所有的字符编码，请注意，如果该字符串代表一个路径，例如 /folder1/folder2/default.html，其中的斜杠也将被编码。这样一来，当该编码结&lt;/p&gt;

&lt;p&gt;果被作为请求发送到 web 服务器时将是无效的。如果字符串中包含不止一个 URI 组件，请使用 encodeURI 方法进行编码。&lt;/p&gt;

&lt;hr&gt;

&lt;h5&gt;正则法获取URL参数&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;function getQueryString(name) { 
    var reg = new RegExp(&amp;quot;(^|&amp;amp;)&amp;quot; + name + &amp;quot;=([^&amp;amp;]*)(&amp;amp;|$)&amp;quot;, &amp;quot;i&amp;quot;); 
    var r = window.location.search.substr(1).match(reg); 
    if (r != null) return unescape(r[2]); return null; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Javascript — 字符串验证</title>
   <link href="http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-string-validate/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-string-validate</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否为空或者全部都是空格
 * 输入：str
 * 返回： 如果全是空返回true,否则返回false
 */
function isNull(str) {
    if (str == &quot;&quot;)
        return true;
    var regu = &quot;^[ ]+$&quot;;
    var re = new RegExp(regu);
    return re.test(str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入对象的值是否符合整数格式
 * 输入：str 输入的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isInteger(str) {
    var regu = /^[-]{0,1}[0-9]{1,}$/;
    return regu.test(str);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入手机号码是否正确
 * 输入： s：字符串 
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkMobile(s) {
//    var regu = /^[1][3][0-9]{9}$/;
    var regu = /^(?:1[2,3,5,8,9]|20)\d{9}$/;
    var re = new RegExp(regu);
    if (re.test(s)) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否符合正整数格式
 * 输入： s：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isNumber(s) {
    var regu = &quot;^[0-9]+$&quot;;
    var re = new RegExp(regu);
    if (s.search(re) != -1) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否是带小数的数字格式,可以是负数
 * 输入： s：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isDecimal(str) {
    if (isInteger(str))
        return true;
    var re = /^[-]{0,1}(\d+)[\.]+(\d+)$/;
    if (re.test(str)) {
        if (RegExp.$1 == 0 &amp;&amp; RegExp.$2 == 0)
            return false;
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入对象的值是否符合端口号格式
 * 输入：str 输入的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isPort(str) {
    return (isNumber(str) &amp;&amp; str &lt; 65536);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入对象的值是否符合E-Mail格式
 * 输入：str 输入的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isEmail(str) {
    var myReg = /^[-_A-Za-z0-9]+@([_A-Za-z0-9]+\.)+[A-Za-z0-9]{2,3}$/;
    if (myReg.test(str))
        return true;
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否符合金额格式 格式定义为带小数的正数，小数点后最多三位
 * 输入： s：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isMoney(s) {
    var regu = &quot;^[0-9]+[\.][0-9]{0,3}$&quot;;
    var re = new RegExp(regu);
    if (re.test(s)) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否只由英文字母和数字和下划线组成
 * 输入： s：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isNumberOr_Letter(s) {// 判断是否是数字或字母

    var regu = &quot;^[0-9a-zA-Z\_]+$&quot;;
    var re = new RegExp(regu);
    if (re.test(s)) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否只由英文字母和数字组成
 * 输入： s：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isNumberOrLetter(s) {// 判断是否是数字或字母

    var regu = &quot;^[0-9a-zA-Z]+$&quot;;
    var re = new RegExp(regu);
    if (re.test(s)) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入字符串是否只由汉字、字母、数字组成
 * 输入： value：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function isChinaOrNumbOrLett(s) {// 判断是否是汉字、字母、数字组成

    var regu = &quot;^[0-9a-zA-Z\u4e00-\u9fa5]+$&quot;;
    var re = new RegExp(regu);
    if (re.test(s)) {
        return true;
    } else {
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：判断是否是日期
 * 输入：date：日期；fmt：日期格式
 * 返回：如果通过验证返回true,否则返回false
 */
function isDate(date, fmt) {
    if (fmt == null)
        fmt = &quot;yyyyMMdd&quot;;

    var yIndex = fmt.indexOf(&quot;yyyy&quot;);
    if (yIndex == -1)
        return false;

    var year = date.substring(yIndex, yIndex + 4);
    var mIndex = fmt.indexOf(&quot;MM&quot;);
    if (mIndex == -1)
        return false;

    var month = date.substring(mIndex, mIndex + 2);
    var dIndex = fmt.indexOf(&quot;dd&quot;);
    if (dIndex == -1)
        return false;

    var day = date.substring(dIndex, dIndex + 2);

    if (!isNumber(year) || year &gt; &quot;2100&quot; || year &lt; &quot;1900&quot;)
        return false;

    if (!isNumber(month) || month &gt; &quot;12&quot; || month &lt; &quot;01&quot;)
        return false;

    if (day &gt; getMaxDay(year, month) || day &lt; &quot;01&quot;)
        return false;

    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
function getMaxDay(year, month) {
    if (month == 4 || month == 6 || month == 9 || month == 11)
        return &quot;30&quot;;
    if (month == 2)
        if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)
            return &quot;29&quot;;
        else
            return &quot;28&quot;;
    return &quot;31&quot;;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：字符1是否以字符串2结束
 * 输入：str1：字符串；str2：被包含的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isLastMatch(str1, str2) {
    var index = str1.lastIndexOf(str2);
    if (str1.length == index + str2.length)
        return true;
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：字符1是否以字符串2开始
 * 输入：str1：字符串；str2：被包含的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isFirstMatch(str1, str2) {
    var index = str1.indexOf(str2);
    if (index == 0)
        return true;
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：字符1是包含字符串2
 * 输入：str1：字符串；str2：被包含的字符串
 * 返回：如果通过验证返回true,否则返回false
 */
function isMatch(str1, str2) {
    var index = str1.indexOf(str2);
    if (index == -1)
        return false;
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入的起止日期是否正确，规则为两个日期的格式正确， 且结束如期&gt;=起始日期
 * 输入： startDate：起始日期，字符串 endDate：结束如期，字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkTwoDate(startDate, endDate) {
    if (!isDate(startDate)) {
        alert(&quot;起始日期不正确!&quot;);
        return false;
    } else if (!isDate(endDate)) {
        alert(&quot;终止日期不正确!&quot;);
        return false;
    } else if (startDate &gt; endDate) {
        alert(&quot;起始日期不能大于终止日期!&quot;);
        return false;
    }
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入的Email信箱格式是否正确
 * 输入： strEmail：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkEmail(strEmail) {
    // var emailReg = /^[_a-z0-9]+@([_a-z0-9]+\.)+[a-z0-9]{2,3}$/;
    var emailReg = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/;
    if (emailReg.test(strEmail)) {
        return true;
    } else {
        alert(&quot;您输入的Email地址格式不正确！&quot;);
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入的电话号码格式是否正确
 * 输入： strPhone：字符串
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkPhone(strPhone) {
    var phoneRegWithArea = /^[0][1-9]{2,3}-[0-9]{5,10}$/;
    var phoneRegNoArea = /^[1-9]{1}[0-9]{5,8}$/;
    var prompt = &quot;您输入的电话号码不正确!&quot;
    if (strPhone.length &gt; 9) {
        if (phoneRegWithArea.test(strPhone)) {
            return true;
        } else {
            alert(prompt);
            return false;
        }
    } else {
        if (phoneRegNoArea.test(strPhone)) {
            return true;
        } else {
            alert(prompt);
            return false;
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查复选框被选中的数目 
 * 输入： checkboxID：字符串 
 * 返回： 返回该复选框中被选中的数目
 */
function checkSelect(checkboxID) {
    var check = 0;
    var i = 0;
    if (document.all(checkboxID).length &gt; 0) {
        for (i = 0; i &lt; document.all(checkboxID).length; i++) {
            if (document.all(checkboxID).item(i).checked) {
                check += 1;
            }

        }
    } else {
        if (document.all(checkboxID).checked)
            check = 1;
    }
    return check;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
function getTotalBytes(varField) {
    if (varField == null)
        return -1;

    var totalCount = 0;
    for (i = 0; i &lt; varField.value.length; i++) {
        if (varField.value.charCodeAt(i) &gt; 127)
            totalCount += 2;
        else
            totalCount++;
    }
    return totalCount;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
function selectAll(checkboxID, status) {

    if (document.all(checkboxID) == null)
        return;

    if (document.all(checkboxID).length &gt; 0) {
        for (i = 0; i &lt; document.all(checkboxID).length; i++) {

            document.all(checkboxID).item(i).checked = status;
        }
    } else {
        document.all(checkboxID).checked = status;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
function selectInverse(checkboxID) {
    if (document.all(checkboxID) == null)
        return;

    if (document.all(checkboxID).length &gt; 0) {
        for (i = 0; i &lt; document.all(checkboxID).length; i++) {
            document.all(checkboxID).item(i).checked = !document
                    .all(checkboxID).item(i).checked;
        }
    } else {
        document.all(checkboxID).checked = !document.all(checkboxID).checked;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
function checkDate(value) {
    if (value == &#39;&#39;)
        return true;
    if (value.length != 8 || !isNumber(value))
        return false;
    var year = value.substring(0, 4);
    if (year &gt; &quot;2100&quot; || year &lt; &quot;1900&quot;)
        return false;

    var month = value.substring(4, 6);
    if (month &gt; &quot;12&quot; || month &lt; &quot;01&quot;)
        return false;

    var day = value.substring(6, 8);
    if (day &gt; getMaxDay(year, month) || day &lt; &quot;01&quot;)
        return false;

    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查输入的起止日期是否正确，规则为两个日期的格式正确或都为空且结束日期&gt;=起始日期
 * 输入： startDate：起始日期，字符串 endDate：结束日期，字符串 
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkPeriod(startDate, endDate) {
    if (!checkDate(startDate)) {
        alert(&quot;起始日期不正确!&quot;);
        return false;
    } else if (!checkDate(endDate)) {
        alert(&quot;终止日期不正确!&quot;);
        return false;
    } else if (startDate &gt; endDate) {
        alert(&quot;起始日期不能大于终止日期!&quot;);
        return false;
    }
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*
 * 用途：检查证券代码是否正确 
 * 输入： secCode:证券代码
 * 返回： 如果通过验证返回true,否则返回false
 */
function checkSecCode(secCode) {
    if (secCode.length != 6) {
        alert(&quot;证券代码长度应该为6位&quot;);
        return false;
    }

    if (!isNumber(secCode)) {
        alert(&quot;证券代码只能包含数字&quot;);

        return false;
    }
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*******************************************************************************
 * function:cTrim(sInputString,iType) description:字符串去空格的函数
 * parameters:iType：1=去掉字符串左边的空格
 *
 * 2=去掉字符串左边的空格 0=去掉字符串左边和右边的空格 return value:去掉空格的字符串
 ******************************************************************************/
function cTrim(sInputString, iType) {
    var sTmpStr = &#39; &#39;;
    var i = -1;

    if (iType == 0 || iType == 1) {
        while (sTmpStr == &#39; &#39;) {
            ++i;
            sTmpStr = sInputString.substr(i, 1);
        }
        sInputString = sInputString.substring(i);
    }

    if (iType == 0 || iType == 2) {
        sTmpStr = &#39; &#39;;
        i = sInputString.length;
        while (sTmpStr == &#39; &#39;) {
            --i;
            sTmpStr = sInputString.substr(i, 1);
        }
        sInputString = sInputString.substring(0, i + 1);
    }
    return sInputString;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/* 
 * 用途：校验ip地址的格式
 * 输入：strIP：ip地址
 * 返回：如果通过验证返回true,否则返回false；
 */
function isIP(strIP) {
    if (isNull(strIP))
        return false;
    // 匹配IP地址的正则表达式
    var re = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/g;
    if (re.test(strIP)) {
        if (RegExp.$1 &lt; 256 &amp;&amp; RegExp.$2 &lt; 256 
            &amp;&amp; RegExp.$3 &lt; 256 &amp;&amp; RegExp.$4 &lt; 256)
            return true;
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;

function getFirstSelectedIndex(checkboxID) {
    var value = -2;
    var i = 0;
    if (document.all(checkboxID).length &gt; 0) {
        for (i = 0; i &lt; document.all(checkboxID).length; i++) {
            if (document.all(checkboxID).item(i).checked) {
                value = i;
                break;
            }
        }
    } else {
        if (document.all(checkboxID).checked)
            value = -1;
    }
    return value;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;

function getFirstSelectedValue(checkboxID) {
    var value = null;
    var i = 0;
    if (document.all(checkboxID).length &gt; 0) {
        for (i = 0; i &lt; document.all(checkboxID).length; i++) {
            if (document.all(checkboxID).item(i).checked) {
                value = document.all(checkboxID).item(i).value;
                break;
            }
        }
    } else {
        if (document.all(checkboxID).checked)
            value = document.all(checkboxID).value;
    }
    return value;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Javascript — 获取项目根路径</title>
   <link href="http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-getbasepath/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/javascript/2015/08/01/Javascript-Javascript-getbasepath</id>
   <content type="html">&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//Javascript获取项目根路径
function getRootPath(){
    //获取当前网址，如： http://localhost:8080/openchina/login.jsp
    var curWwwPath=window.document.location.href;
    //获取主机地址之后的目录，如： uimcardprj/share/meun.jsp
    var pathName=window.document.location.pathname;
    var pos=curWwwPath.indexOf(pathName);
    //获取主机地址，如： http://localhost:8080
    var localhostPath=curWwwPath.substring(0,pos);
    //获取带&amp;quot;/&amp;quot;的项目名，如：/openchina
    var projectName=pathName.substring(0,pathName.substr(1).indexOf(&amp;#39;/&amp;#39;)+1);
    return(localhostPath+projectName);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Java — 获取取得Timestamp类型的当前系统时间</title>
   <link href="http://yinxiaoling.github.io/java/2015/08/01/Java-Java-get-Timestamp/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/08/01/Java-Java-get-Timestamp</id>
   <content type="html">&lt;p&gt;java获取取得Timestamp类型的当前系统时间 格式：2010-11-04 16:19:42 &lt;/p&gt;

&lt;p&gt;方法1： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Timestamp d = new Timestamp(System.currentTimeMillis()); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Date date = new Date();       
Timestamp nousedate = new Timestamp(date.getTime());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;下为相关内容整合&lt;/p&gt;

&lt;p&gt;Java中Date及Timestamp时间相关内容 博客分类： Java编程
JavaSQLDAO.java.util.date java.sql.date java.sql.timestamp &lt;/p&gt;

&lt;p&gt;整理一： &lt;/p&gt;

&lt;p&gt;java.sql.Date 只存储日期数据不存储时间数据 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// 会丢失时间数据
preparedStatement.setDate(1, new java.sql.Date(date.getTime())); 

//可以这样来处理 

preparedStatement.setTimestamp(1, new java.sql.Timestamp(new java.util.Date().getTime())); 


//想要得到完整的数据，包括日期和时间，可以这样 

java.util.Date d = resultSet.getTimestamp(1); 

//这样处理更合适一些，可以避免一些潜在Timestamp 问题 

java.util.Date d = new java.util.Date(resultSet.getTimestamp(1).getTime()); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自己补的话 &lt;/p&gt;

&lt;p&gt;这样的话： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    往数据库存储的时候可以接收 java.util.Date类型 再用getTime()方法得到代表那个Date对象的long值，再以这个long值 构造一个Timestamp对象 存进数据库中。 

   从存数据库里取的时候，可以先得到Timestamp用他的getTime()方法得到long值，再以这个long值构造一个 java.util.Date对象，这样就可以对这个Date对象操作了。不如说 new SimpleTimeFormat(&amp;quot;yyyyy-MM-dd HH:mm:ss&amp;quot;).format()等等 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整理二： &lt;/p&gt;

&lt;p&gt;用Timestamp来记录日期时间还是很方便的，但有时候显示的时候是不需要小数位后面的毫秒的，这样就需要在转换为String时重新定义格式。 &lt;/p&gt;

&lt;p&gt;Timestamp转化为String: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SimpleDateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
//定义格式，不显示毫秒 
Timestamp now = new Timestamp(System.currentTimeMillis());
//获取系统当前时间 
String str = df.format(now);        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;String转化为Timestamp: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SimpleDateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
String time = df.format(new Date()); Timestamp ts = Timestamp.valueOf(time);     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整理三：   在 ResultSet中我们经常使用的setDate或getDate的数据类型是java.sql.Date，而在平时java程序中我们一般习惯使用 java.util.Date。在DAO层我们经常会碰到这俩种数据类型的相互转换：&lt;/p&gt;

&lt;p&gt;两者的关系&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;java.lang.Object
    |
    +---java.util.Date
        |
        +----java.sql.Date 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这个图中我们可以知道java.sql.Date是从java.util.Date继承过来的。&lt;/p&gt;

&lt;p&gt;相互转换 
1. 使用getTime()函数
这两个类都提供了getTime()函数，用于返回对应的毫秒数（long类型）。利用这个函数可以实现转换：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;java.util.Date utilDate = new java.util.Date(sqlDate.getTime());   // sql -&amp;gt; util
java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());   // util -&amp;gt; sql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用SimpleDateFormat类实现转换
SimpleDateFormat 是一个以国别敏感的方式格式化和分析数据的具体类。 它允许格式化 (date -&amp;gt; text)、语法分析 (text -&amp;gt; date)和标准化。&lt;/p&gt;

&lt;p&gt;SimpleDateFormat dateFormat = new SimpleDateFormate(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
java.util.Date utilDate = dateFormat.parse(sqlDate.toString());&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接转换
由于java.sql.Date是从java.util.Date中继承过来的，所以可以直接用：&lt;/p&gt;

&lt;p&gt;utilDate = sqlDate;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另类获得日期的方法：
SimpleDateFormat sy=new SimpleDateFormat(&amp;quot;yyyy&amp;quot;);
SimpleDateFormat sm=new SimpleDateFormat(&amp;quot;MM&amp;quot;);
SimpleDateFormat sd=new SimpleDateFormat(&amp;quot;dd&amp;quot;);
String syear=sy.format(date);
String smon=sm.format(date);
String sday=sd.format(date);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ps： java.util.Date类中的getYear()要加上1900才可得到实际值，getMonth()则要加上1。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — Java数据类型和MySql数据类型对应表</title>
   <link href="http://yinxiaoling.github.io/java/2015/08/01/Java-Java-Datatype-Mysql-Datatype/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/08/01/Java-Java-Datatype-Mysql-Datatype</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th align=&quot;center&quot;&gt;类型名称&lt;/th&gt;
      &lt;th align=&quot;center&quot;&gt;显示长度&lt;/th&gt;
      &lt;th align=&quot;center&quot;&gt;数据库类型&lt;/th&gt;
      &lt;th align=&quot;center&quot;&gt;JAVA类型&lt;/th&gt;
      &lt;th align=&quot;center&quot;&gt;JDBC类型索引(int)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;VARCHAR&lt;/td&gt;
      &lt;td&gt;L+N&lt;/td&gt;
      &lt;td&gt;VARCHAR&lt;/td&gt;
      &lt;td&gt;java.lang.String&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CHAR&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;CHAR&lt;/td&gt;
      &lt;td&gt;java.lang.String&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BLOB&lt;/td&gt;
      &lt;td&gt;L+N&lt;/td&gt;
      &lt;td&gt;BLOB&lt;/td&gt;
      &lt;td&gt;java.lang.byte[]&lt;/td&gt;
      &lt;td&gt;-4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TEXT&lt;/td&gt;
      &lt;td&gt;65535&lt;/td&gt;
      &lt;td&gt;VARCHAR&lt;/td&gt;
      &lt;td&gt;java.lang.String&lt;/td&gt;
      &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;INTEGER UNSIGNED&lt;/td&gt;
      &lt;td&gt;java.lang.Long&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TINYINT&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;TINYINT UNSIGNED&lt;/td&gt;
      &lt;td&gt;java.lang.Integer&lt;/td&gt;
      &lt;td&gt;-6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMALLINT&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;SMALLINT UNSIGNED&lt;/td&gt;
      &lt;td&gt;java.lang.Integer&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MEDIUMINT&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;MEDIUMINT UNSIGNED&lt;/td&gt;
      &lt;td&gt;java.lang.Integer&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIT&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;BIT&lt;/td&gt;
      &lt;td&gt;java.lang.Boolean&lt;/td&gt;
      &lt;td&gt;-7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIGINT&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;BIGINT UNSIGNED&lt;/td&gt;
      &lt;td&gt;java.math.BigInteger&lt;/td&gt;
      &lt;td&gt;-5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;4+8&lt;/td&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;java.lang.Float&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;java.lang.Double&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DECIMAL&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;DECIMAL&lt;/td&gt;
      &lt;td&gt;java.math.BigDecimal&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BOOLEAN&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;TINYINT UNSIGNED&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ID&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;PK (INTEGER UNSIGNED)&lt;/td&gt;
      &lt;td&gt;java.lang.Long&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;java.sql.DATE&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;java.sql.TIME&lt;/td&gt;
      &lt;td&gt;92&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;java.sql.Timestamp&lt;/td&gt;
      &lt;td&gt;93&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIMESTAMP&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;TIMESTAMP&lt;/td&gt;
      &lt;td&gt;java.sql.TIMESTAMP&lt;/td&gt;
      &lt;td&gt;93&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;YEAR&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;YEAR&lt;/td&gt;
      &lt;td&gt;java.sql.Date&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;对于bolb，一般用于对图片的数据库存储，原理是把图片打成二进制，然后进行的一种存储方式，在java中对应byte［］数组。&lt;/p&gt;

&lt;p&gt;对于boolen类型，在mysql数据库中，个人认为用int类型代替较好，对bit操作不是很方便，尤其是在具有web页面开发的项目中，表示0/1，对应java类型的Integer较好。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Hibernate — Hibernate主键生成策略</title>
   <link href="http://yinxiaoling.github.io/hibernate/2015/08/01/Hibernate-Hibernate-Primary-key-generation-strategy/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/hibernate/2015/08/01/Hibernate-Hibernate-Primary-key-generation-strategy</id>
   <content type="html">&lt;h2&gt;简介：&lt;/h2&gt;

&lt;h4&gt;increment：代理主键，适合于所有数据库，由hibernate维护主键自增，和底层数据库无关，但是不适合于2个或以上hibernate进程。&lt;/h4&gt;

&lt;h4&gt;identity：代理主键，适合于Mysql或ms sql server等支持自增的dbms，主键值不由hibernate维护。&lt;/h4&gt;

&lt;h4&gt;sequence：代理主键，适合于oracle等支持序列的dbms，主键值不由hibernate维护，由序列产生。&lt;/h4&gt;

&lt;h4&gt;native：代理主键，根据底层数据库的具体特性选择适合的主键生成策略，如果是mysql或sqlserver，选择identity，如果是oracle，选择sequence。&lt;/h4&gt;

&lt;h4&gt;hilo：代理主键，hibernate把特定表的字段作为hign值，生成主键值&lt;/h4&gt;

&lt;h4&gt;uuid.hex：代理主键，hibernate采用uuid 128位算法生成基于字符串的主键值&lt;/h4&gt;

&lt;h4&gt;assign：适合于应用程序维护的自然主键。&lt;/h4&gt;

&lt;h4&gt;1、自动增长identity&lt;/h4&gt;

&lt;h6&gt;适用于MySQL、DB2、MS SQL Server，采用数据库生成的主键，用于为long、short、int类型生成唯一标识使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）&lt;/h6&gt;

&lt;h6&gt;数据库中的语法如下：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;MySQL：create table t_user(id int auto_increment primary key, name varchar(20));
SQL Server：create table t_user(id int identity(1,1) primary key, name varchar(20));

&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot; type=&amp;quot;long&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;identity&amp;quot; /&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、sequence&lt;/h4&gt;

&lt;h6&gt;DB2、Oracle均支持的序列，用于为long、short或int生成唯一标识&lt;/h6&gt;

&lt;h6&gt;数据库中的语法如下：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Oracle：create sequence seq_name increment by 1 start with 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;需要主键值时可以调用seq&lt;em&gt;name.nextval或者seq&lt;/em&gt;name.curval得到，数据库会帮助我们维护这个sequence序列，保证每次取到的值唯一，如：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;insert into tbl_name(id, name) values(seq_name.nextval, ‘Jimliu’);

&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot; type=&amp;quot;long&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;sequence&amp;quot;&amp;gt;
       &amp;lt;param name=&amp;quot;sequence&amp;quot;&amp;gt;seq_name&amp;lt;/param&amp;gt;
   &amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;如果我们没有指定sequence参数，则Hibernate会访问一个默认的sequence，是hibernate_sequence，我们也需要在数据库中建立这个sequence此外，sequence还可以有另外一个参数是paramters，可以查看Hibernate的API了解它的用法，见org.hibernate.id.SequenceGenerator调用数据库的sequence来生成主键，要设定序列名，不然hibernate无法找到：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;param name=&amp;quot;sequence&amp;quot;&amp;gt;NAME_SEQ&amp;lt;/param&amp;gt;（Oracle中很常用）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3、hilo&lt;/h4&gt;

&lt;h6&gt;使用一个高/低位算法生成的long、short或int类型的标识符，给定一个表和字段作为高位值的来源，默认的表是hibernate&lt;em&gt;unique&lt;/em&gt;key，默认的字段是next_hi。它将id的产生源分成两部分，DB+内存，然后按照算法结合在一起产生id值，可以在很少的连接次数内产生多条记录，提高效率&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;MySQL：create table hi_value(next_hi integer not null);

insert into hi_value(next_hi) values(1);

&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;hilo&amp;quot;&amp;gt;
       &amp;lt;param name=&amp;quot;table&amp;quot;&amp;gt;hi_value&amp;lt;/param&amp;gt;
       &amp;lt;param name=&amp;quot;column&amp;quot;&amp;gt;next_hi&amp;lt;/param&amp;gt;
       &amp;lt;param name=&amp;quot;max_lo&amp;quot;&amp;gt;100&amp;lt;/param&amp;gt;
   &amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;在hibernate持久化的时候，由hibernate负责生成低位值。hilo标识符生成器在生成标识符时需要从hi&lt;em&gt;value表中取出next&lt;/em&gt;hi的当前值，然后修改该值，这个操作是在单独的事务中完成的。最大的低值在属性max&lt;em&gt;lo中配置，但在Hibernate内存中生成的低位值超过此值时，就有需要到数据库的hi&lt;/em&gt;value表中再次读取高位值了使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate&lt;em&gt;unique&lt;/em&gt;key,默认字段为integer类型，名称是next_hi（比较少用）我们也可以自己设置自定义的表名和字段名&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; type=&amp;quot;integer&amp;quot;&amp;gt;
   &amp;lt;column name=&amp;quot;id&amp;quot;/&amp;gt;
   &amp;lt;generator class=&amp;quot;hilo&amp;quot;&amp;gt;
      &amp;lt;param name=&amp;quot;my_unique_key&amp;quot;/&amp;gt;
      &amp;lt;param column=&amp;quot;next_hi&amp;quot;/&amp;gt;
   &amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4、native&lt;/h4&gt;

&lt;h6&gt;会根据底层数据库的能力，从identity、sequence、hilo中选择一个，灵活性更强，但此时，如果选择sequence或者hilo，则所有的表的主键都会从Hibernate默认的sequence或者hilo表中取。并且，有的数据库对于默认情况主键生成测试的支持，效率并不是很高对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server 采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;native&amp;quot; /&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5、seqhilo&lt;/h4&gt;

&lt;h6&gt;sequence和hilo的结合，hilo的高位由sequence产生，所以也需要底层数据库的支持通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用）&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
   &amp;lt;generator class=&amp;quot;seqhilo&amp;quot;&amp;gt;
      &amp;lt;param name=&amp;quot;sequence&amp;quot;&amp;gt;seq_name&amp;lt;/param&amp;gt;
      &amp;lt;param name=&amp;quot;max_lo&amp;quot;&amp;gt;100&amp;lt;/param&amp;gt;
   &amp;lt;/generator&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6、increment&lt;/h4&gt;

&lt;h6&gt;这个是由Hibernate在内存中生成主键，每次增量为1，不依赖于底层的数据库，因此所有的数据库都可以使用，但问题也随之而来，由于是Hibernate生成的，所以只能有一个Hibernate应用进程访问数据库，否则就会产生主键冲突，不能在集群情况下使用插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;increment&amp;quot; /&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7、uuid.hex&lt;/h4&gt;

&lt;h6&gt;使用一个128-bit的UUID算法生成字符串类型的标识符，UUID被编码成一个32位16进制数字的字符串。UUID包含：IP地址、JVM启动时间、系统时间（精确到1/4秒）和一个计数器值（JVM中唯一）&lt;/h6&gt;

&lt;h6&gt;hibernate会算出一个128位的唯一值插入&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;uuid.hex&amp;quot; /&amp;gt;
&amp;lt;/id&amp;gt;


uuid.string
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;hibernate会算出一个16位的值插入&lt;/h6&gt;

&lt;h4&gt;8、assigned&lt;/h4&gt;

&lt;h6&gt;由应用程序负责生成主键标识符，往往使用在数据库中没有代理主键，使用的主键与业务相关的情况，如：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot; type=&amp;quot;string&amp;quot;&amp;gt;
    &amp;lt;generator class=&amp;quot;assigned&amp;quot; /&amp;gt;
&amp;lt;/id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这种主键的生成方式不建议使用，在数据库表设计时就应该使用代理主键（surrogate key），不应使用自然主键（natural key具有业务含义），在没有指定&lt;generator&gt;标签时，默认就是assigned主键的生成方式在插入数据的时候主键由用户自己添加，hibernate也不管&lt;/h6&gt;

&lt;h4&gt;9、foreign&lt;/h4&gt;

&lt;h6&gt;使用外部表的字段作为主键&lt;/h6&gt;

&lt;h4&gt;10、select&lt;/h4&gt;

&lt;h6&gt;使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）&lt;/h6&gt;

&lt;h4&gt;PS:&lt;/h4&gt;

&lt;h6&gt;代理主键是指与业务无关且能唯一标识数据库中记录,一般是数据库自动生成的,比如mysql可以使用auto_increment,Sql2000可以使用identity生成方式,oracle可以使用sequence生成方式 自然主键指业务相关,由用户指定,且能唯一标识数据库中的任意一条记录&lt;/h6&gt;
</content>
 </entry>
 
 <entry>
   <title>Eclipse — 闪瞎你24K钛金狗眼的皮肤插件</title>
   <link href="http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-theme/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-theme</id>
   <content type="html">&lt;blockquote&gt;
&lt;h4&gt;Help-&amp;gt;Install New Software-&amp;gt;add-&amp;gt;Name:Color Theme   Location:http://eclipse-color-theme.github.com/update&lt;/h4&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Eclipse — 实用快捷键整理（基础快捷键未列出）</title>
   <link href="http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-quick-key/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-quick-key</id>
   <content type="html">&lt;h6&gt;1. ctrl+shift+r：打开资源&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几&amp;gt; 个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;2. ctrl+O：快速outline&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的&amp;gt; 所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。
查看一个类的纲要，列出其方法和成员变量。提示：再多按一次Ctrl+O，可以列出该类继承的方法和变量。
助记：&amp;quot;O&amp;quot;---&amp;gt;&amp;quot;Outline&amp;quot;---&amp;gt;&amp;quot;纲要&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;3. ctrl+e：快速转换编辑器&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状&amp;gt; 态下，ctrl+e会更加有效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;4. ctrl+2，L：为本地变量赋值&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。这&amp;gt; 样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;5. alt+shift+r：重命名&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功&amp;gt; 能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使用这个&amp;gt; 功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以&amp;gt; 点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;6. alt+shift+l以及alt+shift+m：提取本地变量及方法&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。&amp;gt; 如果同一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会&amp;gt; 极大的减少复杂度，并提升代码的可测试性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;7. shift+enter及ctrl+shift+enter&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;8. Alt+方向键&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;9. ctrl+m&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;10. ctrl+.及ctrl+1：下一个错误及快速修改&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的&amp;gt; 修改建议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;11. Ctrl+Alt+H&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你想知道一个类的方法到底被那些其他的类调用，那么请选中这个方法名，然后按“Ctrl+Alt+H”，
Eclipse就会显示出这个方法被哪些方法调用，最终产生一个调用关系树。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;12. Ctrl+左键&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;这个是大多数人经常用到的，用来查看变量、方法、类的定义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;13. Ctrl+T&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;查看一个类的继承关系树，是自顶向下的，再多按一次Ctrl+T, 会换成自底向上的显示结构。
提示：选中一个方法名，按Ctrl+T，可以查看到有这个同名方法的父类、子类、接口。
助记：&amp;quot;T&amp;quot;-------&amp;gt;&amp;quot;Tree&amp;quot;-----&amp;gt;&amp;quot;层次树&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;14.Alt+左右方向键&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键
”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚才退回的阅读位置，就像浏览器的
前进和后退按钮一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6&gt;15.导入包：&lt;/h6&gt;

&lt;blockquote&gt;
&lt;p&gt;Ctrl+Shift+O &lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Eclipse — TODO FIXME XXX介绍说明</title>
   <link href="http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-TODOFIXMEXXX/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/eclipse/2015/08/01/Eclipse-Eclipse-TODOFIXMEXXX</id>
   <content type="html">&lt;h3&gt;TODO: + 说明：&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;FIXME: + 说明：&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;如果代码中有该标识，说明标识处代码需要修正/代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;XXX: + 说明：&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>CSS — 鼠标放上时a标签有underline，且鼠标变成手型</title>
   <link href="http://yinxiaoling.github.io/css/2015/08/01/CSS-a/"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/css/2015/08/01/CSS-a</id>
   <content type="html">&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:link&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;text-decoration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;text-decoration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:hover&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#B5B5B5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;text-decoration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;underline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:active&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;text-decoration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Java — split函数详细说明</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-split/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-split</id>
   <content type="html">&lt;p&gt;Java中的split函数详细说明如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;String strtest = &amp;quot;1,2,&amp;quot;;

String arry[] = strtest.split(&amp;quot;,&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样得到的数组元素个数只是2两个，为什么呢，最后一个&amp;quot;,&amp;quot;后没有内容，它没有作为空字符串成为第三个数组元素，结尾的空字符串被丢弃了。&lt;/p&gt;

&lt;p&gt;这个函数还有另一种重载方式 ：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public String [] split (String regex, int limit)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下说明limit 参数控制模式应用的次数，因此影响所得数组的长度。如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n ，而且数组的最后一项将包含所有超出最后匹配的定界符的输入。如果 n 为非正，那么模式将被应用尽可能多的次数，而且数组可以是任何长度。如果 n 为 0，那么模式将被应用尽可能多的次数，数组可以是任何长度，并且结尾空字符串将被丢弃。&lt;/p&gt;

&lt;p&gt;而对于函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public String [] split (String regex)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法的作用就是使用给定的表达式和限制参数 0 来调用两参数 split方法。因此，所得数组中不包括结尾空字符串&lt;/p&gt;

&lt;p&gt;所以如果不想让结尾的空字符串被丢弃，那么应该这样写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;String strtest = &amp;quot;1,2,&amp;quot;;

String arry[] = strtest.split(&amp;quot;,&amp;quot;, -1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Java — Web开发中的字符集</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-Web-charset/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-Web-charset</id>
   <content type="html">&lt;p&gt;在Java语言中，涉及修改编码的地方大概总结包括以下这几部分：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;浏览器、服务器、数据库、操作系统&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;浏览器：
如果使用模板语言，html需要设置显示的字符集。这个适用于浏览器判断什么编码显示。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;metahttp-equiv=&amp;quot;Content-Type&amp;quot;content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展，浏览器识别编码的顺序：&lt;/p&gt;

&lt;p&gt;1.如果HTTP头部申明了charset，则会使用HTTP头部的，&lt;/p&gt;

&lt;p&gt;2.让HTTP头部没有设置，则会去解析meta标签的，&lt;/p&gt;

&lt;p&gt;3.如果meta也没有的话，浏览器会根据是否设置了auto detect来进行编码识别，&lt;/p&gt;

&lt;p&gt;4.否则会使用本地UI的字符编码。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;服务器：
对于JSP等动态语言，需要在jsp头部设置编码格式，J2EE服务器解析JSP时才会把整个页面编码为UTF-8输出，不然就按照系统默认编码格式ISO-8859-1输出了。&lt;/p&gt;

&lt;p&gt;JSP设置格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%@ page language= &amp;quot;java&amp;quot; contentType = &amp;quot;text/html; charset=UTF-8&amp;quot; pageEncoding =&amp;quot;UTF-8&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家都知道，JSP对应的就是servlet。servlet的编码对应如下设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;publicvoid service(HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException{
     response.setContentType(&amp;quot;text/html;charset=utf-8&amp;quot;);    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;还有不要漏掉大家常用的spring工具类，编码转换filter，很实用。在你用struts、spring mvc时这个过滤器帮你转换没有设置的编码过滤。如下设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;filter&amp;gt;    
&amp;lt;filter-name&amp;gt; Set Character Encoding&amp;lt;/filter-name&amp;gt;    
&amp;lt;filter-class&amp;gt;    
     org.springframework.web.filter.CharacterEncodingFilter    
&amp;lt;/filter-class&amp;gt;    
&amp;lt;init-param&amp;gt;    
&amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;    
&amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;    
&amp;lt;/init-param&amp;gt;    
&amp;lt;/filter&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;万一还有乱码怎么办呢？doGet方式的参数传递肯定会有乱码问题。只需要在tomcat的监听器里设置编码字符集如下（文件一般存储在 /tomcat安装目录/conf/server.xml ）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;Connectorport=&amp;quot;80&amp;quot;protocol=&amp;quot;HTTP/1.1&amp;quot; connectionTimeout=&amp;quot;20000&amp;quot;    redirectPort=&amp;quot;8443&amp;quot;URIEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家在开发的时候别忘了java文件本身也是有编码格式的。在类文件右键查看属性。&lt;/p&gt;

&lt;p&gt;如果开发时忘记更改文件的编码格式，windows默认是GBK的，后来又要一直到utf8编码的linux怎么办。文件巨多，总不能一个一个去更改吧。其实很简单，只需要在java命令的环境参数设置 -Dfile.encoding=GBK 解决。&lt;/p&gt;

&lt;p&gt;编译java代码时，如果使用ant需要在javac里设置编译的字符集。这样打印的log输出到文件或者控制台上就不会乱码了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;javacdebuglevel= &amp;quot;source,lines&amp;quot;source= &amp;quot;1.6&amp;quot;encoding= &amp;quot;utf-8&amp;quot;&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;maven编译时设置的字符集：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;artifactId&amp;gt; maven-compiler-plugin &amp;lt;/artifactId&amp;gt;    
&amp;lt;version&amp;gt; 2.5 &amp;lt;/version&amp;gt;    

&amp;lt;configuration&amp;gt;    
&amp;lt;optimize&amp;gt; true &amp;lt;/optimize&amp;gt;    
&amp;lt;showDeprecation&amp;gt; false &amp;lt;/showDeprecation&amp;gt;    
&amp;lt;debuglevel&amp;gt; lines,source &amp;lt;/debuglevel&amp;gt;    
&amp;lt;source&amp;gt; 1.6 &amp;lt;/source&amp;gt;    
&amp;lt;target&amp;gt; 1.6 &amp;lt;/target&amp;gt;    
&amp;lt;encoding&amp;gt; UTF-8 &amp;lt;/encoding&amp;gt;    
&amp;lt;meminitial&amp;gt; 128m &amp;lt;/meminitial&amp;gt;    
&amp;lt;maxmem&amp;gt; 768m &amp;lt;/maxmem&amp;gt;    

&amp;lt;/configuration&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sqlmap的sql xml，sping的xml 也是需要设置的，因为涉及到跨平台。 顶上添加：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!--?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?--&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库：
这里列出大家用的最多的Mysql字符集设置。打开mysql的配置文件( linux 一般在 /etc/my.cnf ，windows在mysql的安装目录 my.ini)。设置如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[mysqld]    
default-character-set = utf8    

[ mysql]    
character_set_server = utf8    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jdbc需要设置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;jdbc : mysql://192.168.0.237:3306/dzh_db?useUnicode=true&amp;amp;characterEncoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些都设置了一般的中文是不会有问题的。
不过最近出现了一个问题很搞怪。以前以为所有的字符只要设置好了所有数据都可以录入数据库，结果有些字符就不行，比如●■★这类型的。后来把这些字符变成字节码，居然不是三位utf8的，我擦，大汗淋漓。后来查询可以通过过滤utf8 特殊字符的方式处理。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;publicstaticString Utf2String (byte buf[]){    
    int len = buf.length;    
    StringBuffer sb =newStringBuffer(len /2);    
    for(int i =0; i &amp;amp;lt; len; i++){    

        if(by2int(buf[i])&amp;amp;lt;= 0x7F)    
            sb.append((char) buf[i]);    
        elseif(by2int(buf[i])&amp;amp;lt;= 0xDF &amp;amp;amp;&amp;amp;amp; by2int(buf[i])&amp;amp;gt;= 0xC0){    
            int bh = by2int(buf[i]&amp;amp;amp; 0x1F);    
            int bl = by2int(buf[++i]&amp;amp;amp; 0x3F);    

            bl = by2int(bh &amp;amp;lt;&amp;amp;lt;6| bl); bh = by2int(bh &amp;amp;gt;&amp;amp;gt;2);    
            int c = bh &amp;amp;lt;&amp;amp;lt;8| bl;    
            sb.append((char) c);    
        }elseif(by2int(buf[i])&amp;amp;lt;= 0xEF &amp;amp;amp;&amp;amp;amp; by2int(buf[i])&amp;amp;gt;= 0xE0){    
            int bh = by2int(buf[i]&amp;amp;amp; 0x0F);    
            int bl = by2int(buf[++i]&amp;amp;amp; 0x3F);    
            int bll = by2int(buf[++i]&amp;amp;amp; 0x3F);    

            bh = by2int(bh &amp;amp;lt;&amp;amp;lt;4| bl &amp;amp;gt;&amp;amp;gt;2);    
            bl = by2int(bl &amp;amp;lt;&amp;amp;lt;6| bll);    

            int c = bh &amp;amp;lt;&amp;amp;lt;8| bl;    
            // 空格转换为半角    
            if(c ==58865){    
                    c =32;    
            }    
            sb.append((char) c);    

        }    
    }    
    return sb.toString();    
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者把mysql的字符集改为 utf8mb4 ，记得这个只有mysql55支持.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[mysqld]    
default-character-set =utf8mb4    

[ mysql]    
character_set_server = utf8mb4    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作系统：
windows默认是gbk，一般不需要变动。不过大家又想每个文件都要建立为utf8格式怎么办，不可能我们每个文件建立后都去用属性改变一下？太麻烦！直接在eclipse设置后，同种类型的文件建立都会是utf8格式。&lt;/p&gt;

&lt;p&gt;linux，可以有两个地方修改基本就足够了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;vi /etc/sysconfig/i18n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LANG=&amp;quot;zh_CN.GB3212&amp;quot;    
LANGUAGE=&amp;quot;zh_CN.GB18030:zh_CN.GB2312:zh_CN&amp;quot;    
SUPPORTED=&amp;quot;zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en&amp;quot;    

vi /etc/profile    
export LC_ALL=&amp;quot;zh_CN.GB2312&amp;quot;    
export LANG=&amp;quot;zh_CN.GB2312&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Java — 事务</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-Transaction/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-Transaction</id>
   <content type="html">&lt;h4&gt;什么是事务?&lt;/h4&gt;

&lt;p&gt;通常的观念，事务（transaction）只与数据库有关。&lt;/p&gt;

&lt;p&gt;事务（transaction）必须服从ISO/IEC所制定的ACID原则。&lt;/p&gt;

&lt;p&gt;ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;事务的原子性（atomicity）&lt;/strong&gt;表示事务执行过程中的任何失败都将导致事务所做的任何更改失效。&lt;br&gt;
原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;事务的一致性（consistency）&lt;/strong&gt;表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。&lt;br&gt;
一致性的概念是：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;事务的隔离性（isolation）&lt;/strong&gt;表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。&lt;br&gt;
隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;事务的持久性（durability）&lt;/strong&gt;表示已经提交的数据在事务执行失败时，数据的状态都应该正确。&lt;br&gt;
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;事务的概念从数据库而来，那么Java的事务是什么呢?他们之间有什么关联呢?&lt;/h4&gt;

&lt;p&gt;实际上，Java应用系统如果要操作数据库是通过JDBC来实现，CRUD都是通过相应方法间接的来实现的，事务的控制也相应的转移到了Java程序代码中来，因此，数据库操作的事务习惯上就称为Java事务。&lt;/p&gt;

&lt;h4&gt;为什么需要事务?&lt;/h4&gt;

&lt;p&gt;事务是为了解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;银行转账业务，账户A要将自己账户上的1000元转到B账户下面，首先A账户余额减1000元，然后B账户余额加1000元。&lt;br&gt;
假如在中间网络出现了问题，A账户减1000元操作已经完成，而B账户加1000元操作因为网络中断而操作失败，那么整&lt;br&gt;
个业务失败，必须做出控制，让A账户的转账业务撤销。这样才能保证业务的正确性，完成这个操作就需要事务，将A&lt;br&gt;
账户减1000元操作和B账户加1000元操作放到一个事务里面，要么全部执行成功，要么操作全部撤销，这样就保证了数&lt;br&gt;
据的安全性。&lt;/p&gt;

&lt;h4&gt;事务的隔离级别&lt;/h4&gt;

&lt;p&gt;多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。&lt;/p&gt;

&lt;p&gt;如果事务不考虑隔离性可能引发的问题：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;脏读：&lt;/strong&gt;&lt;em&gt;&lt;strong&gt;一个事务读取了另外一个事务未提交的数据。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这是非常危险的，假设Ａ向Ｂ转帐100元，对应sql语句如下所示:
    1.update account set money=money+100 where name=&amp;#39;B&amp;#39;;&lt;br&gt;
    2.update account set money=money-100  where name=&amp;#39;A&amp;#39;;
当第1条sql执行完，第2条还没执行(A未提交时)，如果此时Ｂ查询自己的帐户，就会发现自己多了100元钱。如果A等B走后再回滚，B就会损失100元。&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;不可重复读：&lt;/strong&gt;&lt;em&gt;&lt;strong&gt;不可重复读是指在一个事物内读取表中某一行数据，多次读取结果不同。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;例如银行想查询A帐户余额，第一次查询A帐户为200元，此时A向帐户内存了100元并提交了，银行接着又进行了一次查询，此时A帐户为300元了。银行两次查询不一致，可能就会很困惑，不知道哪次查询是准的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;很多人认为这种情况就对了，无须困惑，当然是后面的为准。我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和写到文件中，结果在一个事务中针对输出的目的地，进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作人员就不知道以哪个为准了。&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;虚读(幻读):&lt;/strong&gt;&lt;em&gt;&lt;strong&gt;虚读(幻读)是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如丙存款100元未提交，这时银行做报表统计account表中所有用户的总额为500元，然后丙提交了，这时银行再统计发现帐户为600元了，造成虚读同样会使银行不知所措，到底以哪个为准。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — Session深度解析</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-Session/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-Session</id>
   <content type="html">&lt;h5&gt;一、简介&lt;/h5&gt;

&lt;h6&gt;1.广义的session&lt;/h6&gt;

&lt;p&gt;中文名：会话，http客户端和http服务端开始通信，即产生会话，会话过程是可以连续的，也可以是时断时续的，它会有一个时间范围，表现就是比如你登陆一个网站，如果长时间未操作，网站会提醒你，这就是对session的一种应用。&lt;/p&gt;

&lt;h6&gt;2.J2EE中的session&lt;/h6&gt;

&lt;p&gt;J2EE规范中，session被定义为一个具体的接口，java.servlet.http.HttpSession,这个接口最终由符合J2EE规范的应用服务器来实现，例如我们常用的tomcat、weblogic、websphere等，session通常是存储在服务器内存中的（也有其他存储方式），换句话说session是服务器创建的，而不是浏览器创建的。&lt;/p&gt;

&lt;h5&gt;二、生命周期&lt;/h5&gt;

&lt;h6&gt;1.session的创建&lt;/h6&gt;

&lt;p&gt;session是服务器创建的对象，存储在服务器的内存中，以tomcat为例：&lt;/p&gt;

&lt;p&gt;当浏览器访问一个JSP时，tomcat会先根据JSP生成java文件，编译成class文件，最后运行，并输出内容到浏览器，浏览器解析展示结果给用户。java和class文件会存放在tomcat的work目录下，此时进入你项目中某个jsp所在文件夹会看到xxx&lt;em&gt;jsp.java文件。打开这个java文件我们找到`&lt;/em&gt;jspService`方法，会看到声明了一些我们常说的jsp内置对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;PageContext pageContext = null;

HttpSession session = null;

ServletContext application = null;

JspWriter out = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再往下看，会看到有一句session = pageContext.getSession();，这里生成了session对象，也就是说，访问jsp时，服务器自动生成了session对象(可以在jsp的page声明中加入session=&amp;quot;false&amp;quot;，禁用session)。&lt;/p&gt;

&lt;p&gt;启动一个应用，初次访问服务器上的一个jsp，服务器在响应头中设置了临时cookie，并加上了一JSESSIONID。&lt;/p&gt;

&lt;p&gt;再次访问此jsp页面，浏览器将存储JSESSIONID的cookie随着请求一起发送到服务器，服务器通过JSESSIONID到内存中找到上次生成的session对象，从而实现客户端(浏览器)共享session。&lt;/p&gt;

&lt;p&gt;JSESSIONID也可以拼在url上，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;http:///localhost:8080/test/test.jsp;JSESSIONID=XXXXXXXXXXXX?param1=value1，
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSESSIONID可以通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;request.getSession().getId()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到，url中如果有JSESSIONID，服务器就不会从cookie中取了。&lt;/p&gt;

&lt;p&gt;注：浏览器多个tab之间(同一域下)共享session，实际上就是临时cookie都一样，JSESSIONID都是一个。而多个窗口之间使用不同的cookie不一样，所以不能共享session。&lt;/p&gt;

&lt;h6&gt;2. session的销毁&lt;/h6&gt;

&lt;p&gt;服务器被强制关闭，如Tomcat正常关闭(使用shutdown，而不是X掉)的话，是会对session序列化到硬盘上的，重新启动后，会读取，原有的session依然存在。&lt;/p&gt;

&lt;p&gt;程序中调用session.invalidate()，销毁当前session方法。&lt;/p&gt;

&lt;p&gt;session超时，超时指的是服务器连续一段时间内(超出了应用中设置的最低时限)没有接收到session所在客户端的请求，服务器从内存中移除该session对象。&lt;/p&gt;

&lt;p&gt;浏览器窗口关闭，session会消失吗？&lt;/p&gt;

&lt;p&gt;浏览器关闭后，只是对应服务器session的JSESSIONID消失了，而服务器再也用不到这个session，导致超时，服务器会自动销毁。
注：文中讨论的session只是存储在服务器内存的情况，如其它放在Cache中、分布式存储、持久化等暂不讨论。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;session是消耗服务器内存的，要合理使用session。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;session是服务器创建的，跟浏览器没关系，浏览器只是拿到一个JSESSIONID。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文章转自：&lt;a href=&quot;http://blog.csdn.net/ghsau/article/details/13023425&quot;&gt;高爽|Coder&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — 反射</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-Reflection/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-Reflection</id>
   <content type="html">&lt;h6&gt;Java语言允许通过程序化的方式间接的对Class进行操作，Class文件由类装载器装载后，在JVM中形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：构造函数、属性、方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。&lt;/h6&gt;

&lt;h6&gt;简单实例：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lyndon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;arthas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;menethil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * userName:（变量描述：用户名）  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * @since 1.0.0  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        */&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * passWord:（变量描述：密码）  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * @since 1.0.0  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        */&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * 默认构造函数.    &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        */&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**  &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * 带参构造函数.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * @param userName&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        * @param passWord&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        */&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;userName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;passWord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;userName:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;passWord:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;省略getter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setter&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;一般情况下我们使用如下代码创建User的实例：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setUserName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;用户&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;或者&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;用户&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;密码&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;以上两种方法都采用传统方式的直接调用目标类的方法，下面我们通过Java反射机制以一种更加通用的方式间接地操作目标类：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initByDefaultConst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//通过类装载器获取User类对象&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getContextClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;com.java.lyndon.arthas.menethil.base.User&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//获取类的默认构造器并通过它实例化User&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//通过反射方法设置属性&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setUname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;setUserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;setUname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;用户&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setPword&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;setPassWord&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;setPword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;密码&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initByDefaultConst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;运行结果：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;userName:用户passWord:密码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这说明我们完全可以通过编程方式调用Class的各项功能，这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。&lt;/h6&gt;

&lt;h6&gt;在Test中，使用了几个重要的反射类，分别是ClassLoader、Class、Constructor和Method，通过这些反射类就可以间接调用目标Class的各项功能了。我们获取当前线程的ClassLoader，然后通过指定的全限定类“com.java.lyndon.arthas.menethil.base.User”装载User类对应的反射实例。在②处，我们通过User的反射类对象获取User的构造函数对象cons，通过构造函数对象的newInstrance()方法实例化Car对象，其效果等同于new Car()。我们又通过User的反射类对象的getMethod（String methodName,Class paramClass）获取属性的Setter方法对象，第一个参数是目标Class的方法名；第二个参数是方法入参的对象类型。获取方法反射对象后，即可通过invoke（Object obj,Object param）方法调用目标类的方法，该方法的第一个参数是操作的目标类对象实例；第二个参数是目标方法的入参。&lt;/h6&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — FileUtils介绍</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/31/Java-FileUtils/"/>
   <updated>2015-07-31T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/31/Java-FileUtils</id>
   <content type="html">&lt;p&gt;Java的文件操作太基础，缺乏很多实用工具，比如对目录的操作，支持就非常的差了。如果你经常用Java操作文件或文件夹，你会觉得反复编写这些代码是令人沮丧的问题，而且要大量用到递归。
    下面是的一个解决方案，借助Apache Commons IO工具包（commons-io-1.1.jar）来简单实现文件（夹）的复制、移动、删除、获取大小等操作。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import org.apache.commons.io.FileUtils; 
import org.apache.commons.io.filefilter.*; 
import org.apache.commons.logging.Log; 
import org.apache.commons.logging.LogFactory;

import java.io.*;

/** 
* 文件工具箱 
* 
* @author leizhimin 2008-12-15 13:59:16 
*/ 
public final class FileToolkit { 
    private static final Log log = LogFactory.getLog(FileToolkit.class);

    /** 
     * 复制文件或者目录,复制前后文件完全一样。 
     * 
     * @param resFilePath 源文件路径 
     * @param distFolder    目标文件夹 
     * @IOException 当操作发生异常时抛出 
     */ 
    public static void copyFile(String resFilePath, String distFolder) throws IOException { 
            File resFile = new File(resFilePath); 
            File distFile = new File(distFolder); 
            if (resFile.isDirectory()) { 
                    FileUtils.copyDirectoryToDirectory(resFile, distFile); 
            } else if (resFile.isFile()) { 
                    FileUtils.copyFileToDirectory(resFile, distFile, true); 
            } 
    }

    /** 
     * 删除一个文件或者目录 
     * 
     * @param targetPath 文件或者目录路径 
     * @IOException 当操作发生异常时抛出 
     */ 
    public static void deleteFile(String targetPath) throws IOException { 
            File targetFile = new File(targetPath); 
            if (targetFile.isDirectory()) { 
                    FileUtils.deleteDirectory(targetFile); 
            } else if (targetFile.isFile()) { 
                    targetFile.delete(); 
            } 
    }

    /** 
     * 移动文件或者目录,移动前后文件完全一样,如果目标文件夹不存在则创建。 
     * 
     * @param resFilePath 源文件路径 
     * @param distFolder    目标文件夹 
     * @IOException 当操作发生异常时抛出 
     */ 
    public static void moveFile(String resFilePath, String distFolder) throws IOException { 
            File resFile = new File(resFilePath); 
            File distFile = new File(distFolder); 
            if (resFile.isDirectory()) { 
                    FileUtils.moveDirectoryToDirectory(resFile, distFile, true); 
            } else if (resFile.isFile()) { 
                    FileUtils.moveFileToDirectory(resFile, distFile, true); 
            } 
    }


    /** 
     * 重命名文件或文件夹 
     * 
     * @param resFilePath 源文件路径 
     * @param newFileName 重命名 
     * @return 操作成功标识 
     */ 
    public static boolean renameFile(String resFilePath, String newFileName) { 
            String newFilePath = StringToolkit.formatPath(StringToolkit.getParentPath(resFilePath) + &amp;quot;/&amp;quot; + newFileName); 
            File resFile = new File(resFilePath); 
            File newFile = new File(newFilePath); 
            return resFile.renameTo(newFile); 
    }

    /** 
     * 读取文件或者目录的大小 
     * 
     * @param distFilePath 目标文件或者文件夹 
     * @return 文件或者目录的大小，如果获取失败，则返回-1 
     */ 
    public static long genFileSize(String distFilePath) { 
            File distFile = new File(distFilePath); 
            if (distFile.isFile()) { 
                    return distFile.length(); 
            } else if (distFile.isDirectory()) { 
                    return FileUtils.sizeOfDirectory(distFile); 
            } 
            return -1L; 
    }

    /** 
     * 判断一个文件是否存在 
     * 
     * @param filePath 文件路径 
     * @return 存在返回true，否则返回false 
     */ 
    public static boolean isExist(String filePath) { 
            return new File(filePath).exists(); 
    }

    /** 
     * 本地某个目录下的文件列表（不递归） 
     * 
     * @param folder ftp上的某个目录 
     * @param suffix 文件的后缀名（比如.mov.xml) 
     * @return 文件名称列表 
     */ 
    public static String[] listFilebySuffix(String folder, String suffix) { 
            IOFileFilter fileFilter1 = new SuffixFileFilter(suffix); 
            IOFileFilter fileFilter2 = new NotFileFilter(DirectoryFileFilter.INSTANCE); 
            FilenameFilter filenameFilter = new AndFileFilter(fileFilter1, fileFilter2); 
            return new File(folder).list(filenameFilter); 
    }

    /** 
     * 将字符串写入指定文件(当指定的父路径中文件夹不存在时，会最大限度去创建，以保证保存成功！) 
     * 
     * @param res            原字符串 
     * @param filePath 文件路径 
     * @return 成功标记 
     */ 
    public static boolean string2File(String res, String filePath) { 
            boolean flag = true; 
            BufferedReader bufferedReader = null; 
            BufferedWriter bufferedWriter = null; 
            try { 
                    File distFile = new File(filePath); 
                    if (!distFile.getParentFile().exists()) distFile.getParentFile().mkdirs(); 
                    bufferedReader = new BufferedReader(new StringReader(res)); 
                    bufferedWriter = new BufferedWriter(new FileWriter(distFile)); 
                    char buf[] = new char[1024];         //字符缓冲区 
                    int len; 
                    while ((len = bufferedReader.read(buf)) != -1) { 
                            bufferedWriter.write(buf, 0, len); 
                    } 
                    bufferedWriter.flush(); 
                    bufferedReader.close(); 
                    bufferedWriter.close(); 
            } catch (IOException e) { 
                    flag = false; 
                    e.printStackTrace(); 
            } 
            return flag; 
    } 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;


/**
* 字符串工具箱
*
* @author leizhimin 2008-12-15 22:40:12
*/
public final class StringToolkit {
  /**
  * 将一个字符串的首字母改为大写或者小写
  *
  * @param srcString 源字符串
  * @param flag     大小写标识，ture小写，false大些
  * @return 改写后的新字符串
  */
  public static String toLowerCaseInitial(String srcString, boolean flag) {
    StringBuilder sb = new StringBuilder();
    if (flag) {
        sb.append(Character.toLowerCase(srcString.charAt(0)));
    } else {
        sb.append(Character.toUpperCase(srcString.charAt(0)));
    }
    sb.append(srcString.substring(1));
    return sb.toString();
  }

  /**
  * 将一个字符串按照句点（.）分隔，返回最后一段
  *
  * @param clazzName 源字符串
  * @return 句点（.）分隔后的最后一段字符串
  */
  public static String getLastName(String clazzName) {
    String[] ls = clazzName.split(&amp;quot;\\.&amp;quot;);
    return ls[ls.length - 1];
  }

  /**
  * 格式化文件路径，将其中不规范的分隔转换为标准的分隔符,并且去掉末尾的&amp;quot;/&amp;quot;符号。
  *
  * @param path 文件路径
  * @return 格式化后的文件路径
  */
  public static String formatPath(String path) {
    String reg0 = &amp;quot;\\\\＋&amp;quot;;
    String reg = &amp;quot;\\\\＋|/＋&amp;quot;;
    String temp = path.trim().replaceAll(reg0, &amp;quot;/&amp;quot;);
    temp = temp.replaceAll(reg, &amp;quot;/&amp;quot;);
    if (temp.endsWith(&amp;quot;/&amp;quot;)) {
        temp = temp.substring(0, temp.length() - 1);
    }
    if (System.getProperty(&amp;quot;file.separator&amp;quot;).equals(&amp;quot;\\&amp;quot;)) {
      temp= temp.replace(&amp;#39;/&amp;#39;,&amp;#39;\\&amp;#39;);
    }
    return temp;
  }

  /**
  * 格式化文件路径，将其中不规范的分隔转换为标准的分隔符,并且去掉末尾的&amp;quot;/&amp;quot;符号(适用于FTP远程文件路径或者Web资源的相对路径)。
  *
  * @param path 文件路径
  * @return 格式化后的文件路径
  */
  public static String formatPath4Ftp(String path) {
    String reg0 = &amp;quot;\\\\＋&amp;quot;;
    String reg = &amp;quot;\\\\＋|/＋&amp;quot;;
    String temp = path.trim().replaceAll(reg0, &amp;quot;/&amp;quot;);
    temp = temp.replaceAll(reg, &amp;quot;/&amp;quot;);
    if (temp.endsWith(&amp;quot;/&amp;quot;)) {
        temp = temp.substring(0, temp.length() - 1);
    }
    return temp;
  }

  public static void main(String[] args) {
    System.out.println(System.getProperty(&amp;quot;file.separator&amp;quot;));
    Properties p = System.getProperties();
    System.out.println(formatPath(&amp;quot;C:///\\xxxx\\\\\\\\\\///\\\\R5555555.txt&amp;quot;));

//     List&amp;lt;String&amp;gt; result = series2List(&amp;quot;asdf | sdf|siii|sapp|aaat| &amp;quot;, &amp;quot;\\|&amp;quot;);
//     System.out.println(result.size());
//     for (String s : result) {
//         System.out.println(s);
//     }
  }

  /**
  * 获取文件父路径
  *
  * @param path 文件路径
  * @return 文件父路径
  */
  public static String getParentPath(String path) {
    return new File(path).getParent();
  }

  /**
  * 获取相对路径
  *
  * @param fullPath 全路径
  * @param rootPath 根路径
  * @return 相对根路径的相对路径
  */
  public static String getRelativeRootPath(String fullPath, String rootPath) {
    String relativeRootPath = null;
    String _fullPath = formatPath(fullPath);
    String _rootPath = formatPath(rootPath);

    if (_fullPath.startsWith(_rootPath)) {
        relativeRootPath = fullPath.substring(_rootPath.length());
    } else {
        throw new RuntimeException(&amp;quot;要处理的两个字符串没有包含关系，处理失败！&amp;quot;);
    }
    if (relativeRootPath == null) return null;
    else
        return formatPath(relativeRootPath);
  }

  /**
  * 获取当前系统换行符
  *
  * @return 系统换行符
  */
  public static String getSystemLineSeparator() {
    return System.getProperty(&amp;quot;line.separator&amp;quot;);
  }

  /**
  * 将用“|”分隔的字符串转换为字符串集合列表，剔除分隔后各个字符串前后的空格
  *
  * @param series 将用“|”分隔的字符串
  * @return 字符串集合列表
  */
  public static List&amp;lt;String&amp;gt; series2List(String series) {
    return series2List(series, &amp;quot;\\|&amp;quot;);
  }

  /**
  * 将用正则表达式regex分隔的字符串转换为字符串集合列表，剔除分隔后各个字符串前后的空格
  *
  * @param series 用正则表达式分隔的字符串
  * @param regex 分隔串联串的正则表达式
  * @return 字符串集合列表
  */
  private static List&amp;lt;String&amp;gt; series2List(String series, String regex) {
    List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;String&amp;gt;();
    if (series != null &amp;amp;&amp;amp; regex != null) {
        for (String s : series.split(regex)) {
          if (s.trim() != null &amp;amp;&amp;amp; !s.trim().equals(&amp;quot;&amp;quot;)) result.add(s.trim());
        }
    }
    return result;
  }

  /**
  * @param strList 字符串集合列表
  * @return 通过“|”串联为一个字符串
  */
  public static String list2series(List&amp;lt;String&amp;gt; strList) {
    StringBuffer series = new StringBuffer();
    for (String s : strList) {
        series.append(s).append(&amp;quot;|&amp;quot;);
    }
    return series.toString();
  }

  /**
  * 将字符串的首字母转为小写
  *
  * @param resStr 源字符串
  * @return 首字母转为小写后的字符串
  */
  public static String firstToLowerCase(String resStr) {
    if (resStr == null) {
        return null;
    } else if (&amp;quot;&amp;quot;.equals(resStr.trim())) {
        return &amp;quot;&amp;quot;;
    } else {
        StringBuffer sb = new StringBuffer();
        Character c = resStr.charAt(0);
        if (Character.isLetter(c)) {
          if (Character.isUpperCase(c))
            c = Character.toLowerCase(c);
          sb.append(resStr);
          sb.setCharAt(0, c);
          return sb.toString();
        }
    }
    return resStr;
  }

  /**
  * 将字符串的首字母转为大写
  *
  * @param resStr 源字符串
  * @return 首字母转为大写后的字符串
  */
  public static String firstToUpperCase(String resStr) {
    if (resStr == null) {
        return null;
    } else if (&amp;quot;&amp;quot;.equals(resStr.trim())) {
        return &amp;quot;&amp;quot;;
    } else {
        StringBuffer sb = new StringBuffer();
        Character c = resStr.charAt(0);
        if (Character.isLetter(c)) {
          if (Character.isLowerCase(c))
            c = Character.toUpperCase(c);
          sb.append(resStr);
          sb.setCharAt(0, c);
          return sb.toString();
        }
    }
    return resStr;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转载自：&lt;a href=&quot;http://www.blogjava.net/alexprefect/articles/292937.html&quot;&gt;博客园&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java — HTTP 状态代码及其定义</title>
   <link href="http://yinxiaoling.github.io/java/2015/07/30/Java-HTTP-states/"/>
   <updated>2015-07-30T00:00:00+08:00</updated>
   <id>http://yinxiaoling.github.io/java/2015/07/30/Java-HTTP-states</id>
   <content type="html">&lt;p&gt;2xx  成功&lt;/p&gt;

&lt;p&gt;200  正常；请求已完成。  &lt;/p&gt;

&lt;p&gt;201  正常；紧接 POST 命令。  &lt;/p&gt;

&lt;p&gt;202  正常；已接受用于处理，但处理尚未完成。  &lt;/p&gt;

&lt;p&gt;203  正常；部分信息 — 返回的信息只是一部分。  &lt;/p&gt;

&lt;p&gt;204  正常；无响应 — 已接收请求，但不存在要回送的信息。  &lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;3xx  重定向  &lt;/p&gt;

&lt;p&gt;301  已移动 — 请求的数据具有新的位置且更改是永久的。  &lt;/p&gt;

&lt;p&gt;302  已找到 — 请求的数据临时具有不同 URI。  &lt;/p&gt;

&lt;p&gt;303  请参阅其它 — 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。  &lt;/p&gt;

&lt;p&gt;304  未修改 — 未按预期修改文档。  &lt;/p&gt;

&lt;p&gt;305  使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。  &lt;/p&gt;

&lt;p&gt;306  未使用 — 不再使用；保留此代码以便将来使用。  &lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;4xx  客户机中出现的错误  &lt;/p&gt;

&lt;p&gt;400  错误请求 — 请求中有语法问题，或不能满足请求。  &lt;/p&gt;

&lt;p&gt;401  未授权 — 未授权客户机访问数据。  &lt;/p&gt;

&lt;p&gt;402  需要付款 — 表示计费系统已有效。  &lt;/p&gt;

&lt;p&gt;403  禁止 — 即使有授权也不需要访问。  &lt;/p&gt;

&lt;p&gt;404  找不到 — 服务器找不到给定的资源；文档不存在。  &lt;/p&gt;

&lt;p&gt;407  代理认证请求 — 客户机首先必须使用代理认证自身。  &lt;/p&gt;

&lt;p&gt;415  介质类型不受支持 — 服务器拒绝服务请求，因为不支持请求实体的格式。  &lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;5xx  服务器中出现的错误  &lt;/p&gt;

&lt;p&gt;500  内部错误 — 因为意外情况，服务器不能完成请求。  &lt;/p&gt;

&lt;p&gt;501  未执行 — 服务器不支持请求的工具。  &lt;/p&gt;

&lt;p&gt;502  错误网关 — 服务器接收到来自上游服务器的无效响应。&lt;/p&gt;

&lt;p&gt;503  无法获得服务 — 由于临时过载或维护，服务器无法处理请求。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;HTTP 400 - 请求无效 &lt;/p&gt;

&lt;p&gt;HTTP 401.1 - 未授权：登录失败 &lt;/p&gt;

&lt;p&gt;HTTP 401.2 - 未授权：服务器配置问题导致登录失败 &lt;/p&gt;

&lt;p&gt;HTTP 401.3 - ACL 禁止访问资源 &lt;/p&gt;

&lt;p&gt;HTTP 401.4 - 未授权：授权被筛选器拒绝 &lt;/p&gt;

&lt;p&gt;HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败  &lt;/p&gt;

&lt;p&gt;HTTP 403 - 禁止访问 &lt;/p&gt;

&lt;p&gt;HTTP 403 - 对 Internet 服务管理器 (HTML) 的访问仅限于 Localhost &lt;/p&gt;

&lt;p&gt;HTTP 403.1 禁止访问：禁止可执行访问 &lt;/p&gt;

&lt;p&gt;HTTP 403.2 - 禁止访问：禁止读访问 &lt;/p&gt;

&lt;p&gt;HTTP 403.3 - 禁止访问：禁止写访问 &lt;/p&gt;

&lt;p&gt;HTTP 403.4 - 禁止访问：要求 SSL &lt;/p&gt;

&lt;p&gt;HTTP 403.5 - 禁止访问：要求 SSL 128 &lt;/p&gt;

&lt;p&gt;HTTP 403.6 - 禁止访问：IP 地址被拒绝 &lt;/p&gt;

&lt;p&gt;HTTP 403.7 - 禁止访问：要求客户证书 &lt;/p&gt;

&lt;p&gt;HTTP 403.8 - 禁止访问：禁止站点访问 &lt;/p&gt;

&lt;p&gt;HTTP 403.9 - 禁止访问：连接的用户过多 &lt;/p&gt;

&lt;p&gt;HTTP 403.10 - 禁止访问：配置无效 &lt;/p&gt;

&lt;p&gt;HTTP 403.11 - 禁止访问：密码更改 &lt;/p&gt;

&lt;p&gt;HTTP 403.12 - 禁止访问：映射器拒绝访问 &lt;/p&gt;

&lt;p&gt;HTTP 403.13 - 禁止访问：客户证书已被吊销 &lt;/p&gt;

&lt;p&gt;HTTP 403.15 - 禁止访问：客户访问许可过多 &lt;/p&gt;

&lt;p&gt;HTTP 403.16 - 禁止访问：客户证书不可信或者无效 &lt;/p&gt;

&lt;p&gt;HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 &lt;/p&gt;

&lt;p&gt;HTTP 404.1 - 无法找到 Web 站点 &lt;/p&gt;

&lt;p&gt;HTTP 404 - 无法找到文件 &lt;/p&gt;

&lt;p&gt;HTTP 405 - 资源被禁止 &lt;/p&gt;

&lt;p&gt;HTTP 406 - 无法接受 &lt;/p&gt;

&lt;p&gt;HTTP 407 - 要求代理身份验证 &lt;/p&gt;

&lt;p&gt;HTTP 410 - 永远不可用 &lt;/p&gt;

&lt;p&gt;HTTP 412 - 先决条件失败 &lt;/p&gt;

&lt;p&gt;HTTP 414 - 请求 - URI 太长 &lt;/p&gt;

&lt;p&gt;HTTP 500 - 内部服务器错误 &lt;/p&gt;

&lt;p&gt;HTTP 500.100 - 内部服务器错误 - ASP 错误 &lt;/p&gt;

&lt;p&gt;HTTP 500-11 服务器关闭 &lt;/p&gt;

&lt;p&gt;HTTP 500-12 应用程序重新启动 &lt;/p&gt;

&lt;p&gt;HTTP 500-13 - 服务器太忙 &lt;/p&gt;

&lt;p&gt;HTTP 500-14 - 应用程序无效 &lt;/p&gt;

&lt;p&gt;HTTP 500-15 - 不允许请求 global.asa &lt;/p&gt;

&lt;p&gt;Error 501 - 未实现 &lt;/p&gt;

&lt;p&gt;HTTP 502 - 网关错误&lt;/p&gt;
</content>
 </entry>
 

</feed>
