<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Framework — IOC详解 &middot; 尹枭凌
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/naringu.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/form.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="./public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <link rel="alternate" type="application/rss+xml" title="Mozilla RSS" href="feed.category.xml">
  </head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48740529-1', 'auto');
  ga('send', 'pageview');

</script>


<body class="theme-6dd">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
      <img width="200" height="180" alt="A photo of ariestiyansyah" src="/images/head.jpeg">
    <p align="center">If I know what love is, <br />it is because of you.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">首页</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">关于我</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/categories/">分类</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/contact/">联系方式</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    

    <a class="sidebar-nav-item" href="https://github.com/yinxiaoling">GitHub project</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2015. All rights reserved.
    </p>
  </div>
</div>


    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">尹枭凌</a>
            <small>—因为有了因为，所以有了所以，既然已成既然，何必再问何必。</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Framework — IOC详解</h1>
  <span class="post-date">16 Aug 2015</span>
  <p>转载请注明出处：<a href="http://stamen.iteye.com/blog/1489223">ITEYE</a></p>

<h4>IOC（控制反转：Inverse of Control）是Spring的内核，AOP和声明式事务等都是在此基础上开花结果的。</h4>

<h1>IOC的概念</h1>

<p>读了S大的文章豁然开朗下面来让我们通过实例说明IOC的概念。</p>

<p>贺岁大片在中国已经形成了一个传统，张之亮的《墨攻》讲述了战国时期墨家人革离帮助梁国反抗赵国侵略的个人英雄主义故事，其中有这样一个场景：当刘德华饰演的墨者革离到达梁国都城下，城上梁国守军问到：“来者何人？”，刘德华答道：“墨者革离！”。我们不妨通过一个Java类来为这个“城门叩问”的场景进行编剧，并以此来理解IOC的概念：</p>

<p>MoAttack：通过演员安排剧本</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MoAttack {
    public void cityGateAsk(){
        //（壹）演员直接侵入剧本
        LiuDeHua ldh = new LiuDeHua();
        ldh.responseAsk(&quot;墨者革离！&quot;);
    }
}
</code></pre></div>
<p>我们会发现以上剧本在（壹）处，作为具体角色饰演者的刘德华直接侵入了剧本，使剧本和演员直接耦合在一起。</p>

<p><img src="http://dl.iteye.com/upload/attachment/0066/7636/f7676f68-e41e-3883-a37f-046ae379c321.jpg" alt=""></p>

<p>一个明智的编剧在剧情创作时应围绕故事的角色进行，而不应考虑角色的具体饰演者，这样才可能在剧本投拍时自由地遴选任何适合的演员，而非绑定在刘德华一人身上。通过以上的分析，我们知道需要为该剧本主人公革离定义一个接口： </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MoAttack {
   public void cityGateAsk() {
        //①引入革离角色接口
       GeLi geli = new LiuDeHua(); 

        //②通过接口开展剧情
       geli.responseAsk(&quot;墨者革离！&quot;);  
   }
}
</code></pre></div>
<p>在①处引入了剧本的角色-革离，剧本的剧情通过角色展开，在拍摄时角色由演员饰演，如②处所示。</p>

<p><img src="http://dl.iteye.com/upload/attachment/0066/7640/14d800d6-3505-3ca3-b21b-01194aaf0a83.jpg" alt=""></p>

<p>可是我们可以看出MoAttack同时依赖于GeLi接口和LiuDeHua类，并没有达到我们所期望的剧本仅依赖于角色的目的。但是角色最终必须通过具体的演员才能完成拍摄，如何让LiuDeHua类与剧本无关，而又能完成GeLi的具体动作呢?当然是影片投入拍摄时，导演将LiuDeHua安排在GeLi的角色上，导演将剧本，角色，饰演者装配起来。</p>

<p><img src="http://dl.iteye.com/upload/attachment/0066/7642/24018187-7df1-3657-8464-545eabdf456a.jpg" alt="通过引入导演剧本和饰演者解耦"></p>

<p>通过引入导演，使剧本和具体饰演者解耦了。对应到软件中，导演像是一个装配器，安排演员表演具体的角色。 </p>

<p>现在我们反过来讲解IOC的概念，IOC（控制反转）包括2个部分的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1、控制
2、反转
</code></pre></div>
<p>那么到底是什么东西的“控制”被“反转”了呢?</p>

<p>对应到前面的例子，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">“控制”是指选择GeLi角色饰演者的控制权
“反转”是指这种控制权从《墨攻》剧本中移除，转交到导演手中（对于软件来说：某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定）
</code></pre></div>
<p>因为IOC确实晦涩难懂，因此业界曾进行了广泛的讨论，最终软件界的泰斗级人物Martin Fowler提出了DI（依赖注入：Dependency Injection）的概念用以替代IOC，即让调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。“依赖注入”显然比“控制反转”直接明了，易于理解。</p>

<h1>IOC的类型</h1>

<p>从注入方法上主要可以分为三种类型：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">构造函数注入
属性注入
接口注入
</code></pre></div>
<p>Spring支持构造函数注入和属性注入，下面继续使用上面的例子来说明这三种注入方法的区别。</p>

<h2>构造函数注入</h2>

<p>在构造函数注入中，我们通过调用类的构造函数，将接口实现类通过构造函数变量传入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MoAttack {
   private GeLi geli;
   //①注入革离的具体扮演者
   public MoAttack(GeLi geli){ 
       this.geli = geli;
   }
    public void cityGateAsk(){
       geli.responseAsk(&quot;墨者革离！&quot;);
   }
}
</code></pre></div>
<p>MoAttack的构造函数不关心具体是谁扮演革离这个角色，只要在①处传入的扮演者按剧本要求完成相应的表演即可。角色的具体扮演者由导演来安排:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Director {
   public void direct(){
        //①指定角色的扮演者
       GeLi geli = new LiuDeHua();  

        //②注入具体扮演者到剧本中
       MoAttack moAttack = new MoAttack(geli); 
       moAttack.cityGateAsk();
   }
}
</code></pre></div>
<p>在①处，导演安排刘德华饰演革离的角色，并在②处，将刘德华“注入”到墨攻的剧本中，然后开始“城门叩问”剧情的演出工作。</p>

<h2>属性注入</h2>

<p>有时，导演会发现，虽然墨者革离是《墨攻》的第一主角，但并非每个场景都需要革离出现，在此情况下使用构造函数注入相当于革离每时每刻都在场，可见并不妥当，这时候就可以考虑属性注入。属性注入可以有选择的通过setter方法完成调用类所需依赖的注入，更加灵活方便：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MoAttack {
    private GeLi geli;
     //①属性注入方法
    public void setGeli(GeLi geli) {  
        this.geli = geli;
    }
    public void cityGateAsk() {
        geli.responseAsk(&quot;墨者革离&quot;);
    }
}
</code></pre></div>
<p>MoAttack在①处为geli属性提供一个Setter方法，以便让导演在需要时注入geli的具体扮演者。 </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Director {
   public void direct(){
       GeLi geli = new LiuDeHua();
       MoAttack moAttack = new MoAttack();

        //①调用属性Setter方法注入
       moAttack.setGeli(geli); 
       moAttack.cityGateAsk();
   }
}
</code></pre></div>
<p>和通过构造函数注入革离扮演者不同，在实例化MoAttack剧本时，并未指定任何扮演者，而是在实例化MoAttack后，在需要革离出场时，才调用其setGeli()方法注入扮演者。按照类似的方式，我们还可以分别为剧本中其他诸如梁王、巷淹中等角色提供注入的Setter方法，这样，导演就可以根据所拍剧段的不同，注入相应的角色了。 </p>

<h2>接口注入</h2>

<p>将调用类所有的依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法。为了采取接口注入方式，必须先声明一个ActorArrangable接口：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface ActorArrangable {
   void injectGeli(GeLi geli);
}
</code></pre></div>
<p>然后MoAttack实现ActorArrangable接口提供具体的实现： </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MoAttack implements ActorArrangable {
    private GeLi geli;
     //①实现接口方法
    public void injectGeli (GeLi geli) {  
        this.geli = geli;       
    }
    public void cityGateAsk() {
        geli.responseAsk(&quot;墨者革离&quot;);
    }
}
</code></pre></div>
<p>Director通过ActorArrangable的injectGeli()方法完成扮演者的注入工作:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Director {
   public void direct(){
       GeLi geli = new LiuDeHua();
       MoAttack moAttack = new MoAttack();
       moAttack. injectGeli (geli);
       moAttack.cityGateAsk();
   }
}
</code></pre></div>
<p>由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，因此我们不提倡采用这种方式。 </p>

<h1>通过容器完成依赖关系的注入</h1>

<p>虽然MoAttack和LiuDeHua实现了解耦，MoAttack无须关注角色实现类的实例化工作，但这些工作在代码中依然存在，只是转移到Director类中而已。假设某一制片人想改变这一局面，在选择某个剧本后，希望通过一个“海选”或者第三中介机构来选择导演、演员，让他们各司其职，那剧本、导演、演员就都实现解耦了。 </p>

<p>所谓媒体“海选”和第三方中介机构在程序领域即是一个第三方的容器，它帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中脱离出来，专注于更有意义的业务逻辑开发工作。这无疑是一件令人向往的事情，Spring就是这样的一个容器，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。下面是Spring配置文件的对以上实例进行配置的配置文件片断： </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
        &lt;!--①实现类实例化--&gt;
   &lt;bean id=&quot;geli&quot; class=&quot;LiuDeHua&quot;/&gt;
   &lt;bean id=&quot;moAttack&quot; class=&quot;com.baobaotao.ioc.MoAttack&quot; 
         p:geli-ref=&quot;geli&quot;/&gt;&lt;!--②通过geli-ref建立依赖关系--&gt;
&lt;/beans&gt;
</code></pre></div>
<p>通过new XmlBeanFactory(“beans.xml”)等方式即可启动容器。在容器启动时，Spring根据配置文件的描述信息，自动实例化Bean并完成依赖关系的装配，从容器中即可返回准备就绪的Bean实例，后续可直接使用之。 </p>

<p>Spring为什么会有这种“神奇”的力量，仅凭一个简单的配置文件，就能魔法般地实例化并装配好程序所用的Bean呢？这种“神奇”的力量归功于Java语言本身的类反射功能。 详见<a href="http://yinxiaoling.github.io/java/2015/07/31/Java-Reflection/">Java-反射</a></p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/java/2015/08/12/Java-HTTP-hypertext-transfer-protocol/">
            Java — HTTP 协议详解
            <small>12 Aug 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/git/2015/08/06/Git-Git-command/">
            Git — Git常用命令速查表
            <small>06 Aug 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/others/2015/08/01/other-qizongzui/">
            Others — 让你此生难成大器的七宗罪
            <small>01 Aug 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div class="comments">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'testnaringu';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'testnaringu';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>

    <div align="center" class="footer">
        Copyright © 2015 <br>
    </div>
  </body>
</html>

