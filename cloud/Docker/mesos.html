<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mesos - 优秀的集群资源调度平台 | Hsiao Lin</title>
    <meta name="description" content="Programer &amp; WOWER">
    <link rel="icon" href="/pig32.png">
    
    <link rel="preload" href="/assets/css/0.styles.bd66f28f.css" as="style"><link rel="preload" href="/assets/js/app.365f7fea.js" as="script"><link rel="preload" href="/assets/js/46.6247d916.js" as="script"><link rel="prefetch" href="/assets/js/10.e8ab10a4.js"><link rel="prefetch" href="/assets/js/11.d1cb4148.js"><link rel="prefetch" href="/assets/js/12.cba34369.js"><link rel="prefetch" href="/assets/js/13.5145e463.js"><link rel="prefetch" href="/assets/js/14.6bdbabb2.js"><link rel="prefetch" href="/assets/js/15.2888418d.js"><link rel="prefetch" href="/assets/js/16.2489649d.js"><link rel="prefetch" href="/assets/js/17.cea64679.js"><link rel="prefetch" href="/assets/js/18.3245683f.js"><link rel="prefetch" href="/assets/js/19.c6e0b481.js"><link rel="prefetch" href="/assets/js/2.7d83e6da.js"><link rel="prefetch" href="/assets/js/20.bbf67aae.js"><link rel="prefetch" href="/assets/js/21.cbcd4f96.js"><link rel="prefetch" href="/assets/js/22.b98d076e.js"><link rel="prefetch" href="/assets/js/23.ee7c5e7e.js"><link rel="prefetch" href="/assets/js/24.dd380e87.js"><link rel="prefetch" href="/assets/js/25.5c721af1.js"><link rel="prefetch" href="/assets/js/26.efb21d01.js"><link rel="prefetch" href="/assets/js/27.0fe303e8.js"><link rel="prefetch" href="/assets/js/28.566b68de.js"><link rel="prefetch" href="/assets/js/29.7b36cb29.js"><link rel="prefetch" href="/assets/js/3.68587e58.js"><link rel="prefetch" href="/assets/js/30.de9fac57.js"><link rel="prefetch" href="/assets/js/31.ef52e435.js"><link rel="prefetch" href="/assets/js/32.e2eaaa49.js"><link rel="prefetch" href="/assets/js/33.192d3a03.js"><link rel="prefetch" href="/assets/js/34.6008ae4e.js"><link rel="prefetch" href="/assets/js/35.e8816b78.js"><link rel="prefetch" href="/assets/js/36.a5a28ad5.js"><link rel="prefetch" href="/assets/js/37.a3173678.js"><link rel="prefetch" href="/assets/js/38.c4732683.js"><link rel="prefetch" href="/assets/js/39.0c57fbbe.js"><link rel="prefetch" href="/assets/js/4.e5ec2def.js"><link rel="prefetch" href="/assets/js/40.025b70cc.js"><link rel="prefetch" href="/assets/js/41.6a7897c8.js"><link rel="prefetch" href="/assets/js/42.4303301b.js"><link rel="prefetch" href="/assets/js/43.e76fd56e.js"><link rel="prefetch" href="/assets/js/44.bebdc742.js"><link rel="prefetch" href="/assets/js/45.3315f2c0.js"><link rel="prefetch" href="/assets/js/47.07bba9f9.js"><link rel="prefetch" href="/assets/js/48.e2bf896e.js"><link rel="prefetch" href="/assets/js/49.00e40c2a.js"><link rel="prefetch" href="/assets/js/5.dd2f6f9c.js"><link rel="prefetch" href="/assets/js/50.281dd4e2.js"><link rel="prefetch" href="/assets/js/51.ae1cb580.js"><link rel="prefetch" href="/assets/js/52.e2522b14.js"><link rel="prefetch" href="/assets/js/6.b9d02d3e.js"><link rel="prefetch" href="/assets/js/7.dc6a90bf.js"><link rel="prefetch" href="/assets/js/8.ad98fdcd.js"><link rel="prefetch" href="/assets/js/9.84c920cc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bd66f28f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hsiao Lin</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/Java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/Java/Spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/Java/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/Java/SpringCloud/" class="nav-link">SpringCloud</a></li><li class="dropdown-item"><!----> <a href="/Java/MyBatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/Java/algorithm/" class="nav-link">算法</a></li><li class="dropdown-item"><h4>架构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Java/architect/OAuth2/" class="nav-link">OAuth2</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/TypeScript/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Nodejs/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/React/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Angular/" class="nav-link">Angular</a></li></ul></div></div><div class="nav-item"><a href="/BigData/" class="nav-link">BigData</a></div><div class="nav-item"><a href="/AI/" class="nav-link">AI</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Cloud</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cloud/Docker/" class="nav-link router-link-active">Docker</a></li><li class="dropdown-item"><!----> <a href="/cloud/Kubernetes/" class="nav-link">Kubernetes</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/yinxiaoling" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/Java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/Java/Spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/Java/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/Java/SpringCloud/" class="nav-link">SpringCloud</a></li><li class="dropdown-item"><!----> <a href="/Java/MyBatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/Java/algorithm/" class="nav-link">算法</a></li><li class="dropdown-item"><h4>架构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Java/architect/OAuth2/" class="nav-link">OAuth2</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/TypeScript/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Nodejs/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/React/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/Angular/" class="nav-link">Angular</a></li></ul></div></div><div class="nav-item"><a href="/BigData/" class="nav-link">BigData</a></div><div class="nav-item"><a href="/AI/" class="nav-link">AI</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Cloud</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cloud/Docker/" class="nav-link router-link-active">Docker</a></li><li class="dropdown-item"><!----> <a href="/cloud/Kubernetes/" class="nav-link">Kubernetes</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/yinxiaoling" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/cloud/Docker/BasicConcepts.html" class="sidebar-link">Docker基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/BasicConcepts.html#docker-镜像" class="sidebar-link">Docker 镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/BasicConcepts.html#docker-容器" class="sidebar-link">Docker 容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/BasicConcepts.html#docker-registry" class="sidebar-link">Docker Registry</a></li></ul></li><li><a href="/cloud/Docker/Install.html" class="sidebar-link">安装 Docker</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#centos-安装-docker-ce" class="sidebar-link">CentOS 安装 Docker CE</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#macos-安装-docker" class="sidebar-link">MacOS 安装 Docker</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#windows-10-pc-安装-docker-ce" class="sidebar-link">Windows 10 PC 安装 Docker CE</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#ubuntu-安装-docker-ce" class="sidebar-link">Ubuntu 安装 Docker CE</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#debian-安装-docker-ce" class="sidebar-link">Debian 安装 Docker CE</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Install.html#镜像加速器" class="sidebar-link">镜像加速器</a></li></ul></li><li><a href="/cloud/Docker/UseImage.html" class="sidebar-link">使用 Docker 镜像</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#获取镜像" class="sidebar-link">获取镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#列出镜像" class="sidebar-link">列出镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#删除本地镜像" class="sidebar-link">删除本地镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#利用-commit-理解镜像构成" class="sidebar-link">利用 commit 理解镜像构成</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#使用-dockerfile-定制镜像" class="sidebar-link">使用 Dockerfile 定制镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#dockerfile-指令详解" class="sidebar-link">Dockerfile 指令详解</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#多阶段构建" class="sidebar-link">多阶段构建</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#实战多阶段构建-laravel-镜像" class="sidebar-link">实战多阶段构建 Laravel 镜像</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#其它制作镜像的方式" class="sidebar-link">其它制作镜像的方式</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseImage.html#镜像的实现原理" class="sidebar-link">镜像的实现原理</a></li></ul></li><li><a href="/cloud/Docker/UseContainer.html" class="sidebar-link">操作 Docker 容器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#启动容器" class="sidebar-link">启动容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#后台运行" class="sidebar-link">后台运行</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#终止容器" class="sidebar-link">终止容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#进入容器" class="sidebar-link">进入容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#导出和导入容器" class="sidebar-link">导出和导入容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#删除容器" class="sidebar-link">删除容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/UseContainer.html#清理所有处于终止状态的容器" class="sidebar-link">清理所有处于终止状态的容器</a></li></ul></li><li><a href="/cloud/Docker/InterviewRegistry.html" class="sidebar-link">访问仓库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/InterviewRegistry.html#docker-hub" class="sidebar-link">Docker Hub</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/InterviewRegistry.html#私有仓库" class="sidebar-link">私有仓库</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/InterviewRegistry.html#私有仓库高级配置" class="sidebar-link">私有仓库高级配置</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/InterviewRegistry.html#nexus3-x-的私有仓库" class="sidebar-link">Nexus3.x 的私有仓库</a></li></ul></li><li><a href="/cloud/Docker/DataManager.html" class="sidebar-link">Docker 数据管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/DataManager.html#数据卷" class="sidebar-link">数据卷</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/DataManager.html#挂载主机目录" class="sidebar-link">挂载主机目录</a></li></ul></li><li><a href="/cloud/Docker/Network.html" class="sidebar-link">Docker 中的网络功能介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/Network.html#外部访问容器" class="sidebar-link">外部访问容器</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Network.html#容器互联" class="sidebar-link">容器互联</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Network.html#配置-dns" class="sidebar-link">配置 DNS</a></li></ul></li><li><a href="/cloud/Docker/AdvancedNetwork.html" class="sidebar-link">高级网络配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#快速配置指南" class="sidebar-link">快速配置指南</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#容器访问控制" class="sidebar-link">容器访问控制</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#映射容器端口到宿主主机的实现" class="sidebar-link">映射容器端口到宿主主机的实现</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#配置-docker0-网桥" class="sidebar-link">配置 docker0 网桥</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#自定义网桥" class="sidebar-link">自定义网桥</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#工具和示例" class="sidebar-link">工具和示例</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#编辑网络配置文件" class="sidebar-link">编辑网络配置文件</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/AdvancedNetwork.html#示例：创建一个点到点连接" class="sidebar-link">示例：创建一个点到点连接</a></li></ul></li><li><a href="/cloud/Docker/compose.html" class="sidebar-link">Docker 三剑客之 Docker Compose</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#compose-简介" class="sidebar-link">Compose 简介</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#安装与卸载" class="sidebar-link">安装与卸载</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#compose-命令说明" class="sidebar-link">Compose 命令说明</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#compose-模板文件" class="sidebar-link">Compose 模板文件</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#使用-django" class="sidebar-link">使用 Django</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/compose.html#使用-rails" class="sidebar-link">使用 Rails</a></li></ul></li><li><a href="/cloud/Docker/machine.html" class="sidebar-link">Docker 三剑客之 Docker Machine</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/machine.html#安装" class="sidebar-link">安装</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/machine.html#使用" class="sidebar-link">使用</a></li></ul></li><li><a href="/cloud/Docker/swarm.html" class="sidebar-link">Docker 三剑客之 Docker Swarm</a></li><li><a href="/cloud/Docker/swarm_mode.html" class="sidebar-link">Swarm mode</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#创建-swarm-集群" class="sidebar-link">创建 Swarm 集群</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#部署服务" class="sidebar-link">部署服务</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#在-swarm-集群中使用-compose-文件" class="sidebar-link">在 Swarm 集群中使用 compose 文件</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#在-swarm-集群中管理敏感数据" class="sidebar-link">在 Swarm 集群中管理敏感数据</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#在-swarm-集群中管理配置数据" class="sidebar-link">在 Swarm 集群中管理配置数据</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/swarm_mode.html#swarm-mode-与滚动升级" class="sidebar-link">SWarm mode 与滚动升级</a></li></ul></li><li><a href="/cloud/Docker/Security.html" class="sidebar-link">安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#内核命名空间" class="sidebar-link">内核命名空间</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#控制组" class="sidebar-link">控制组</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#docker服务端的防护" class="sidebar-link">Docker服务端的防护</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#内核能力机制" class="sidebar-link">内核能力机制</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#其它安全特性" class="sidebar-link">其它安全特性</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/Security.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/cloud/Docker/underly.html" class="sidebar-link">底层实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#基本架构" class="sidebar-link">基本架构</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#命名空间" class="sidebar-link">命名空间</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#控制组" class="sidebar-link">控制组</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#联合文件系统" class="sidebar-link">联合文件系统</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#容器格式" class="sidebar-link">容器格式</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/underly.html#docker-网络实现" class="sidebar-link">Docker 网络实现</a></li></ul></li><li><a href="/cloud/Docker/etcd.html" class="sidebar-link">Etcd 项目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/etcd.html#什么是-etcd" class="sidebar-link">什么是 etcd</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/etcd.html#安装" class="sidebar-link">安装</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/etcd.html#etcd-集群" class="sidebar-link">etcd 集群</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/etcd.html#使用-etcdctl" class="sidebar-link">使用 etcdctl</a></li></ul></li><li><a href="/cloud/Docker/coreos.html" class="sidebar-link">CoreOS 项目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/coreos.html#coreos-介绍" class="sidebar-link">CoreOS 介绍</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/coreos.html#coreos-特性" class="sidebar-link">CoreOS 特性</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/coreos.html#coreos-工具介绍" class="sidebar-link">CoreOS 工具介绍</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/coreos.html#快速搭建-coreos-集群" class="sidebar-link">快速搭建 CoreOS 集群</a></li></ul></li><li><a href="/cloud/Docker/kubernetes.html" class="sidebar-link">Kubernetes</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/kubernetes.html#项目简介" class="sidebar-link">项目简介</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/kubernetes.html#快速上手" class="sidebar-link">快速上手</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/kubernetes.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/kubernetes.html#kubectl-使用" class="sidebar-link">kubectl 使用</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/kubernetes.html#基本架构" class="sidebar-link">基本架构</a></li></ul></li><li><a href="/cloud/Docker/mesos.html" class="active sidebar-link">Mesos - 优秀的集群资源调度平台</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#mesos-安装与使用" class="sidebar-link">Mesos 安装与使用</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#原理与架构" class="sidebar-link">原理与架构</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#mesos-配置项解析" class="sidebar-link">Mesos 配置项解析</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#日志与监控" class="sidebar-link">日志与监控</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/mesos.html#常见应用框架" class="sidebar-link">常见应用框架</a></li></ul></li><li><a href="/cloud/Docker/cases_os.html" class="sidebar-link">实战-操作系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_os.html#busybox" class="sidebar-link">Busybox</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_os.html#alpine" class="sidebar-link">Alpine</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_os.html#debian-ubuntu" class="sidebar-link">Debian/Ubuntu</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_os.html#centos-fedora" class="sidebar-link">CentOS/Fedora</a></li></ul></li><li><a href="/cloud/Docker/cases_cicd.html" class="sidebar-link">实战-CI/CD</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_cicd.html#drone" class="sidebar-link">Drone</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_cicd.html#参考链接" class="sidebar-link">参考链接</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/cases_cicd.html#在-travis-ci-中使用-docker" class="sidebar-link">在 Travis CI 中使用 Docker</a></li></ul></li><li><a href="/cloud/Docker/opensource.html" class="sidebar-link">Docker 开源项目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/opensource.html#linuxkit" class="sidebar-link">LinuxKit</a></li></ul></li><li><a href="/cloud/Docker/appendix.1.html" class="sidebar-link">附录一：常见问题总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.1.html#镜像相关" class="sidebar-link">镜像相关</a></li></ul></li><li><a href="/cloud/Docker/appendix.2.html" class="sidebar-link">附录二：热门镜像介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#ubuntu" class="sidebar-link">Ubuntu</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#centos" class="sidebar-link">CentOS</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#nginx" class="sidebar-link">Nginx</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#mysql" class="sidebar-link">MySQL</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#mongodb" class="sidebar-link">MongoDB</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#redis" class="sidebar-link">Redis</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.2.html#node-js" class="sidebar-link">Node.js</a></li></ul></li><li><a href="/cloud/Docker/appendix.3.html" class="sidebar-link">附录三：Docker 命令查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.3.html#基本语法" class="sidebar-link">基本语法</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.3.html#客户端命令选项" class="sidebar-link">客户端命令选项</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.3.html#dockerd-命令选项" class="sidebar-link">dockerd 命令选项</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.3.html#客户端命令" class="sidebar-link">客户端命令</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.3.html#一张图总结-docker-的命令" class="sidebar-link">一张图总结 Docker 的命令</a></li></ul></li><li><a href="/cloud/Docker/appendix.4.html" class="sidebar-link">附录四：Dockerfile 最佳实践</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.4.html#一般性的指南和建议" class="sidebar-link">一般性的指南和建议</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.4.html#dockerfile-指令" class="sidebar-link">Dockerfile 指令</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.4.html#官方镜像示例" class="sidebar-link">官方镜像示例</a></li></ul></li><li><a href="/cloud/Docker/appendix.5.html" class="sidebar-link">附录五：如何调试 Docker</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.5.html#开启-debug-模式" class="sidebar-link">开启 Debug 模式</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.5.html#检查内核日志" class="sidebar-link">检查内核日志</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.5.html#docker-不响应时处理" class="sidebar-link">Docker 不响应时处理</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.5.html#重置-docker-本地数据" class="sidebar-link">重置 Docker 本地数据</a></li></ul></li><li><a href="/cloud/Docker/appendix.6.html" class="sidebar-link">附录六：资源链接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.6.html#官方网站" class="sidebar-link">官方网站</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.6.html#实践参考" class="sidebar-link">实践参考</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.6.html#技术交流" class="sidebar-link">技术交流</a></li><li class="sidebar-sub-header"><a href="/cloud/Docker/appendix.6.html#其它" class="sidebar-link">其它</a></li></ul></li></ul> </div> <div class="page"> <div class="content"><h1 id="mesos-优秀的集群资源调度平台"><a href="#mesos-优秀的集群资源调度平台" aria-hidden="true" class="header-anchor">#</a> Mesos - 优秀的集群资源调度平台</h1> <p>Mesos 项目是源自 UC Berkeley 的对集群资源进行抽象和管理的开源项目，类似于操作系统内核，用户可以使用它很容易地实现分布式应用的自动化调度。</p> <p>同时，Mesos 自身也很好地结合和主持了 Docker 等相关容器技术，基于 Mesos 已有的大量应用框架，可以实现用户应用的快速上线。</p> <p>本章将介绍 Mesos 项目的安装、使用、配置以及核心的原理知识。</p> <h2 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h2> <p>Mesos 最初由 UC Berkeley 的 AMP 实验室于 2009 年发起，遵循 Apache 协议，目前已经成立了 Mesosphere 公司进行运营。Mesos 可以将整个数据中心的资源（包括 CPU、内存、存储、网络等）进行抽象和调度，使得多个应用同时运行在集群中分享资源，并无需关心资源的物理分布情况。</p> <p>如果把数据中心中的集群资源看做一台服务器，那么 Mesos 要做的事情，其实就是今天操作系统内核的职责：抽象资源 + 调度任务。Mesos 项目是 Mesosphere 公司 Datacenter Operating System (DCOS) 产品的核心部件。</p> <p>Mesos 项目主要由 C++ 语言编写，项目官方地址为 <a href="https://mesos.apache.org/" target="_blank" rel="noopener noreferrer">https://mesos.apache.org<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，代码仍在快速演化中，已经发布了正式版 1.0.0 版本。</p> <p>Mesos 拥有许多引人注目的特性，包括：</p> <ul><li>支持数万个节点的大规模场景（Apple、Twitter、eBay 等公司实践）；</li> <li>支持多种应用框架，包括 Marathon、Singularity、Aurora 等；</li> <li>支持 HA（基于 ZooKeeper 实现）；</li> <li>支持 Docker、LXC 等容器机制进行任务隔离；</li> <li>提供了多个流行语言的 API，包括 Python、Java、C++ 等；</li> <li>自带了简洁易用的 WebUI，方便用户直接进行操作。</li></ul> <p>值得注意的是，Mesos 自身只是一个资源抽象的平台，要使用它往往需要结合运行其上的分布式应用（在 Mesos 中被称作框架，framework），比如 Hadoop、Spark 等可以进行分布式计算的大数据处理应用；比如 Marathon 可以实现 PaaS，快速部署应用并自动保持运行；比如 ElasticSearch 可以索引海量数据，提供灵活的整合和查询能力……</p> <p>大部分时候，用户只需要跟这些框架打交道即可，完全无需关心底下的资源调度情况，因为 Mesos 已经自动帮你实现了。这大大方便了上层应用的开发和运维。</p> <p>当然，用户也可以基于 Mesos 打造自己的分布式应用框架。</p> <h2 id="mesos-安装与使用"><a href="#mesos-安装与使用" aria-hidden="true" class="header-anchor">#</a> Mesos 安装与使用</h2> <p>以 Mesos 结合 Marathon 应用框架为例，来看下如何快速搭建一套 Mesos 平台。</p> <p>Marathon 是可以跟 Mesos 一起协作的一个 framework，基于 Scala 实现，可以实现保持应用的持续运行。</p> <p>另外，Mesos 默认利用 ZooKeeper 来进行多个主节点之间的选举，以及从节点发现主节点的过程。一般在生产环境中，需要启动多个 Mesos master 服务（推荐 3 或 5 个），并且推荐使用 supervisord 等进程管理器来自动保持服务的运行。</p> <p>ZooKeeper 是一个分布式集群中信息同步的工具，通过自动在多个节点中选举 <code>leader</code>，保障多个节点之间的某些信息保持一致性。</p> <h3 id="安装"><a href="#安装" aria-hidden="true" class="header-anchor">#</a> 安装</h3> <p>安装主要需要 mesos、zookeeper 和 marathon 三个软件包。</p> <p>Mesos 也采用了经典的主-从结构，一般包括若干主节点和大量从节点。其中，mesos master 服务和 zookeeper 需要部署到所有的主节点，mesos slave 服务需要部署到所有从节点。marathon 可以部署到主节点。</p> <p>安装可以通过源码编译、软件源或者 Docker 镜像方式进行，下面分别进行介绍。</p> <h4 id="源码编译"><a href="#源码编译" aria-hidden="true" class="header-anchor">#</a> 源码编译</h4> <p>源码编译方式可以保障获取到最新版本，但编译过程比较费时间。</p> <p>首先，从 apache.org 开源网站下载最新的源码。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ git clone https://git-wip-us.apache.org/repos/asf/mesos.git
</code></pre></div><p>其中，主要代码在 <code>src</code> 目录下，应用框架代码在 <code>frameworks</code> 目录下，文档在 <code>docs</code> 目录下，<code>include</code>中包括了跟 Mesos 打交道使用的一些 API 定义头文件。</p> <p>安装依赖，主要包括 Java 运行环境、Linux 上的自动编译环境等。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo apt-get update
$ sudo apt-get install -y openjdk-8-jdk autoconf libtool \
build-essential python-dev python-boto libcurl4-nss-dev \
libsasl2-dev maven libapr1-dev libsvn-dev
</code></pre></div><p>后面就是常规 C++ 项目的方法，configure 之后利用 Makefile 进行编译和安装。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ cd mesos
$ ./bootstrap
$ mkdir build
$ cd build &amp;&amp; ../configure --with-network-isolator
$ make
$ make check &amp;&amp; sudo make install
</code></pre></div><h4 id="软件源安装"><a href="#软件源安装" aria-hidden="true" class="header-anchor">#</a> 软件源安装</h4> <p>通过软件源方式进行安装相对会省时间，但往往不是最新版本。</p> <p>这里以 Ubuntu 系统为例，首先添加软件源地址。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv E56151BF
$ DISTRO=$(lsb_release -is | tr '[:upper:]' '[:lower:]')
$ CODENAME=$(lsb_release -cs)
$ echo &quot;deb http://repos.mesosphere.io/${DISTRO} ${CODENAME} main&quot; | \
sudo tee /etc/apt/sources.list.d/mesosphere.list
</code></pre></div><p>刷新本地软件仓库信息并安装 zookeeper、mesos、marathon 三个软件包。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo apt-get -y update &amp;&amp; sudo apt-get -y install zookeeper mesos marathon
</code></pre></div><p>注意，Marathon 最新版本需要 jdk 1.8+ 的支持。如果系统中有多个 Java 版本，需要检查配置默认的 JDK 版本符合要求。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo update-alternatives --config java
</code></pre></div><p>安装 Mesos 成功后，会在 <code>/usr/sbin/</code> 下面发现 <code>mesos-master</code> 和 <code>mesos-slave</code> 两个二进制文件，分别对应主节点上需要运行的管理服务和从节点上需要运行的任务服务。</p> <p>用户可以手动运行二进制文件启动服务，也可以通过 <code>service</code> 命令来方便进行管理。</p> <p>例如，在主节点上重启 Mesos 管理服务：</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo service mesos-master restart
</code></pre></div><p>通过 <code>service</code> 命令来管理，实际上是通过调用 <code>/usr/bin/mesos-init-wrapper</code> 脚本文件进行处理。</p> <h4 id="基于-docker"><a href="#基于-docker" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/sekka1/mesosphere-docker" target="_blank" rel="noopener noreferrer">基于 Docker<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>需要如下三个镜像。</p> <ul><li>ZooKeeper：<a href="https://registry.hub.docker.com/u/garland/zookeeper/" target="_blank" rel="noopener noreferrer">https://registry.hub.docker.com/u/garland/zookeeper/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>Mesos：<a href="https://registry.hub.docker.com/u/garland/mesosphere-docker-mesos-master/" target="_blank" rel="noopener noreferrer">https://registry.hub.docker.com/u/garland/mesosphere-docker-mesos-master/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>Marathon：<a href="https://registry.hub.docker.com/u/garland/mesosphere-docker-marathon/" target="_blank" rel="noopener noreferrer">https://registry.hub.docker.com/u/garland/mesosphere-docker-marathon/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>其中 mesos-master 镜像在后面将分别作为 master 和 slave 角色进行使用。</p> <p>首先，拉取三个镜像。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ docker pull garland/zookeeper
$ docker pull garland/mesosphere-docker-mesos-master
$ docker pull garland/mesosphere-docker-marathon
</code></pre></div><p>导出主节点机器的地址到环境变量。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ HOST_IP=10.0.0.2
</code></pre></div><p>在主节点上启动 Zookeepr 容器。</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run -d \
-p 2181:2181 \
-p 2888:2888 \
-p 3888:3888 \
garland/zookeeper
</code></pre></div><p>在主节点上启动 Mesos Master 服务容器。</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run --net=&quot;host&quot; \
-p 5050:5050 \
-e &quot;MESOS_HOSTNAME=${HOST_IP}&quot; \
-e &quot;MESOS_IP=${HOST_IP}&quot; \
-e &quot;MESOS_ZK=zk://${HOST_IP}:2181/mesos&quot; \
-e &quot;MESOS_PORT=5050&quot; \
-e &quot;MESOS_LOG_DIR=/var/log/mesos&quot; \
-e &quot;MESOS_QUORUM=1&quot; \
-e &quot;MESOS_REGISTRY=in_memory&quot; \
-e &quot;MESOS_WORK_DIR=/var/lib/mesos&quot; \
-d \
garland/mesosphere-docker-mesos-master
</code></pre></div><p>在主节点上启动 Marathon。</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run \
-d \
-p 8080:8080 \
garland/mesosphere-docker-marathon --master zk://${HOST_IP}:2181/mesos --zk zk://${HOST_IP}:2181/marathon
</code></pre></div><p>在从节点上启动 Mesos slave 容器。</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run -d \
--name mesos_slave_1 \
--entrypoint=&quot;mesos-slave&quot; \
-e &quot;MESOS_MASTER=zk://${HOST_IP}:2181/mesos&quot; \
-e &quot;MESOS_LOG_DIR=/var/log/mesos&quot; \
-e &quot;MESOS_LOGGING_LEVEL=INFO&quot; \
garland/mesosphere-docker-mesos-master:latest
</code></pre></div><p>接下来，可以通过访问本地 8080 端口来使用 Marathon 启动任务了。</p> <h3 id="配置说明"><a href="#配置说明" aria-hidden="true" class="header-anchor">#</a> 配置说明</h3> <p>下面以本地通过软件源方式安装为例，解释如何修改各个配置文件。</p> <h4 id="zookeepr"><a href="#zookeepr" aria-hidden="true" class="header-anchor">#</a> ZooKeepr</h4> <p>ZooKeepr 是一个分布式应用的协调工具，用来管理多个主节点的选举和冗余，监听在 2181 端口。推荐至少布置三个主节点来被 ZooKeeper 维护。</p> <p>配置文件默认都在 <code>/etc/zookeeper/conf/</code> 目录下。比较关键的配置文件有两个：<code>myid</code> 和 <code>zoo.cfg</code>。</p> <p>myid 文件会记录加入 ZooKeeper 集群的节点的序号（1-255之间）。<code>/var/lib/zookeeper/myid</code> 文件其实也是软连接到了该文件。</p> <p>比如配置某节点序号为 1，则需要在该节点上执行：</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ echo 1 | sudo dd of=/etc/zookeeper/conf/myid
</code></pre></div><p>节点序号在 ZooKeeper 集群中必须唯一，不能出现多个拥有相同序号的节点。</p> <p>另外，需要修改 zoo.cfg 文件，该文件是主配置文件，主要需要添加上加入 ZooKeeper 集群的机器的序号和对应监听地址。</p> <p>例如，现在 ZooKeeper 集群中有三个节点，地址分别为 <code>10.0.0.2</code>、<code>10.0.0.3</code>、<code>10.0.0.4</code>，序号分别配置为 <code>2</code>、<code>3</code>、<code>4</code>。</p> <p>则配置如下的三行：</p> <div class="language-sh extra-class"><pre class="language-text"><code>server.2=10.0.0.2:2888:3888
server.3=10.0.0.3:2888:3888
server.4=10.0.0.4:2888:3888
</code></pre></div><p>其中第一个端口 2888 负责从节点连接到主节点的；第二个端口 3888 则负责主节点进行选举时候通信。</p> <p>也可以用主机名形式，则需要各个节点 <code>/etc/hosts</code> 文件中都记录地址到主机名对应的映射关系。</p> <p>完成配置后，启动 ZooKeeper 服务。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo service zookeeper start
</code></pre></div><h4 id="mesos"><a href="#mesos" aria-hidden="true" class="header-anchor">#</a> Mesos</h4> <p>Mesos 的默认配置目录有三个：</p> <ul><li>/etc/mesos/：主节点和从节点都会读取的配置文件，最关键的是 zk 文件存放主节点的信息；</li> <li>/etc/mesos-master/：只有主节点会读取的配置，等价于启动 mesos-master 命令时候的默认选项；</li> <li>/etc/mesos-slave/：只有从节点会读取的配置，等价于启动 mesos-master 命令时候的默认选项。</li></ul> <p>最关键的是需要在所有节点上修改 <code>/etc/mesos/zk</code>，写入主节点集群的 ZooKeeper 地址列表，例如：</p> <div class="language-sh extra-class"><pre class="language-text"><code>zk://10.0.0.2:2181,10.0.0.3:2181,10.0.0.4:2181/mesos
</code></pre></div><p>此外，<code>/etc/default/mesos</code>、<code>/etc/default/mesos-master</code>、<code>/etc/default/mesos-slave</code> 这三个文件中可以存放一些环境变量定义，Mesos 服务启动之前，会将这些环境变量导入进来作为启动参数。格式为 <code>MESOS_OPTION_NAME</code>。</p> <p>下面分别说明在主节点和从节点上的配置。</p> <h5 id="主节点"><a href="#主节点" aria-hidden="true" class="header-anchor">#</a> 主节点</h5> <p>一般只需要关注 <code>/etc/mesos-master/</code> 目录下的文件。默认情况下目录下为空。</p> <p>该目录下文件命名和内容需要跟 mesos-master 支持的命令行选项一一对应。可以通过 <code>mesos-master --help</code> 命令查看支持的选项。</p> <p>例如某个文件 <code>key</code> 中内容为 <code>value</code>，则在 mesos-master 服务启动的时候，会自动添加参数 <code>--key=value</code> 给二进制命令。</p> <p>例如，mesos-master 服务默认监听在 loopback 端口，即 <code>127.0.0.1:5050</code>，我们需要修改主节点监听的地址，则可以创建 /etc/mesos-master/ip 文件，在其中写入主节点监听的外部地址。</p> <p>为了正常启动 mesos-master 服务，还需要指定 <code>work_dir</code> 参数(表示应用框架的工作目录)的值，可以通过创建 /etc/mesos-master/work_dir 文件，在其中写入目录，例如 <code>/var/lib/mesos</code>。工作目录下会生成一个 <code>replicated_log</code> 目录，会存有各种同步状态的持久化信息。</p> <p>以及指定 quorum 参数的值，该参数用来表示 ZooKeeper 集群中要求最少参加表决的节点数目。一般设置为比 ZooKeeper 集群中节点个数的半数多一些（比如三个节点的话，可以配置为 <code>2</code>）。</p> <p>此外，要修改 Mesos 集群的名称，可以创建 <code>/etc/mesos-master/cluster</code> 文件，在其中写入集群的别名，例如 <code>MesosCluster</code>。</p> <p>总结下，建议在 <code>/etc/mesos-master</code> 目录下，配置至少四个参数文件：<code>ip</code>、<code>quorum</code>、<code>work_dir</code>、<code>cluster</code>。</p> <p>修改配置之后，需要启动服务即可生效。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo service mesos-master start
</code></pre></div><p>更多选项可以参考后面的配置项解析章节。</p> <p>主节点服务启动后，则可以在从节点上启动 mesos-slave 服务来加入主节点的管理。</p> <h5 id="从节点"><a href="#从节点" aria-hidden="true" class="header-anchor">#</a> 从节点</h5> <p>一般只需要关注 <code>/etc/mesos-slave/</code> 目录下的文件。默认情况下目录下为空。</p> <p>文件命名和内容也是跟主节点类似，对应二进制文件支持的命令行参数。</p> <p>建议在从节点上，创建 <code>/etc/mesos-slave/ip</code> 文件，在其中写入跟主节点通信的地址。</p> <p>修改配置之后，也需要重新启动服务。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo service mesos-slave start
</code></pre></div><p>更多选项可以参考后面的配置项解析章节。</p> <h4 id="marathon"><a href="#marathon" aria-hidden="true" class="header-anchor">#</a> Marathon</h4> <p>Marathon 作为 Mesos 的一个应用框架，配置要更为简单，必需的配置项有 <code>--master</code> 和 <code>--zk</code>。</p> <p>安装完成后，会在 /usr/bin 下多一个 marathon shell 脚本，为启动 marathon 时候执行的命令。</p> <p>配置目录为 <code>/etc/marathon/conf</code>（需要手动创建），此外默认配置文件在 <code>/etc/default/marathon</code>。</p> <p>我们手动创建配置目录，并添加配置项（文件命名和内容跟 Mesos 风格一致），让 Marathon 能连接到已创建的 Mesos 集群中。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo mkdir -p /etc/marathon/conf
$ sudo cp /etc/mesos/zk /etc/marathon/conf/master
</code></pre></div><p>同时，让 Marathon 也将自身的状态信息保存到 ZooKeeper 中。创建 <code>/etc/marathon/conf/zk</code> 文件，添加 ZooKeeper 地址和路径。</p> <div class="language-sh extra-class"><pre class="language-text"><code>zk://10.0.0.2:2181,10.0.0.2:2181,10.0.0.2:2181/marathon
</code></pre></div><p>启动 marathon 服务。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ sudo service marathon start
</code></pre></div><h3 id="访问-mesos-图形界面"><a href="#访问-mesos-图形界面" aria-hidden="true" class="header-anchor">#</a> 访问 Mesos 图形界面</h3> <p>Mesos 自带了 Web 图形界面，可以方便用户查看集群状态。</p> <p>用户在 Mesos 主节点服务和从节点服务都启动后，可以通过浏览器访问主节点 5050 端口，看到类似如下界面，已经有两个 slave 节点加入了。</p> <p><img src="https://yeasy.gitbooks.io/docker_practice/mesos/_images/mesos.png" alt="mesos 界面查看加入的 slave 节点">图 1.22.2.1 - mesos 界面查看加入的 slave 节点</p> <p>通过 Slaves 标签页能看到加入集群的从节点的信息。</p> <p>如果没有启动 Marathon 服务，在 Frameworks 标签页下将看不到任何内容。</p> <h3 id="访问-marathon-图形界面"><a href="#访问-marathon-图形界面" aria-hidden="true" class="header-anchor">#</a> 访问 Marathon 图形界面</h3> <p>Marathon 服务启动成功后，在 Mesos 的 web 界面的 Frameworks 标签页下面将能看到名称为 marathon 的框架出现。</p> <p>同时可以通过浏览器访问 8080 端口，看到 Marathon 自己的管理界面。</p> <p><img src="https://yeasy.gitbooks.io/docker_practice/mesos/_images/marathon.png" alt="marathon 图形管理界面">图 1.22.2.2 - marathon 图形管理界面</p> <p>此时，可以通过界面或者 REST API 来创建一个应用，Marathon 会保持该应用的持续运行。</p> <p><img src="https://yeasy.gitbooks.io/docker_practice/mesos/_images/marathon_basic0.png" alt="marathon 查看任务支持的参数">图 1.22.2.3 - marathon 查看任务支持的参数</p> <p>通过界面方式可以看到各任务支持的参数（包括资源、命令、环境变量、健康检查等），同时可以很容易地修改任务运行实例数进行扩展，非常适合进行测试。</p> <p>如果要更自动化地使用 Marathon，则需要通过它的 REST API 进行操作。</p> <p>一般的，启动新任务需要先创建一个定义模板（JSON 格式），然后发到指定的 API。</p> <p>例如，示例任务 basic-0 的定义模板为：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token string">&quot;basic-0&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cmd&quot;</span><span class="token operator">:</span> <span class="token string">&quot;while [ true ] ; do echo 'Hello Marathon' ; sleep 5 ; done&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cpus&quot;</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span>
    <span class="token property">&quot;mem&quot;</span><span class="token operator">:</span> <span class="token number">10.0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;instances&quot;</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该任务申请资源为 0.1 个单核 CPU 资源和 10 MB 的内存资源，具体命令为每隔五秒钟用 shell 打印一句 <code>Hello Marathon</code>。</p> <p>可以通过如下命令发出 basic-0 任务到 Marathon 框架，框架会分配任务到某个满足条件的从节点上，成功会返回一个 json 对象，描述任务的详细信息。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ curl -X POST http://marathon_host:8080/v2/apps -d @basic-0.json -H &quot;Content-type: application/json&quot;
{&quot;id&quot;:&quot;/basic-0&quot;,&quot;cmd&quot;:&quot;while [ true ] ; do echo 'Hello Marathon' ; sleep 5 ; done&quot;,&quot;args&quot;:null,&quot;user&quot;:null,&quot;env&quot;:{},&quot;instances&quot;:1,&quot;cpus&quot;:0.1,&quot;mem&quot;:10,&quot;disk&quot;:0,&quot;executor&quot;:&quot;&quot;,&quot;constraints&quot;:[],&quot;uris&quot;:[],&quot;storeUrls&quot;:[],&quot;ports&quot;:[0],&quot;requirePorts&quot;:false,&quot;backoffSeconds&quot;:1,&quot;backoffFactor&quot;:1.15,&quot;maxLaunchDelaySeconds&quot;:3600,&quot;container&quot;:null,&quot;healthChecks&quot;:[],&quot;dependencies&quot;:[],&quot;upgradeStrategy&quot;:{&quot;minimumHealthCapacity&quot;:1,&quot;maximumOverCapacity&quot;:1},&quot;labels&quot;:{},&quot;acceptedResourceRoles&quot;:null,&quot;version&quot;:&quot;2015-12-28T05:33:05.805Z&quot;,&quot;tasksStaged&quot;:0,&quot;tasksRunning&quot;:0,&quot;tasksHealthy&quot;:0,&quot;tasksUnhealthy&quot;:0,&quot;deployments&quot;:[{&quot;id&quot;:&quot;3ec3fbd5-11e4-479f-bd17-813d33e43e0c&quot;}],&quot;tasks&quot;:[]}%
</code></pre></div><p>Marathon 的更多 REST API 可以参考本地自带的文档：<code>http://marathon_host:8080/api-console/index.html</code>。</p> <p>此时，如果运行任务的从节点出现故障，任务会自动在其它可用的从节点上启动。</p> <p>此外，目前也已经支持基于 Docker 容器的任务。需要先在 Mesos slave 节点上为 slave 服务配置 <code>--containerizers=docker,mesos</code> 参数。</p> <p>例如如下面的示例任务：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token string">&quot;basic-3&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cmd&quot;</span><span class="token operator">:</span> <span class="token string">&quot;python3 -m http.server 8080&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cpus&quot;</span><span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span>
  <span class="token property">&quot;mem&quot;</span><span class="token operator">:</span> <span class="token number">32.0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;container&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;DOCKER&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;volumes&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token property">&quot;docker&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;image&quot;</span><span class="token operator">:</span> <span class="token string">&quot;python:3&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;network&quot;</span><span class="token operator">:</span> <span class="token string">&quot;BRIDGE&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;portMappings&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token property">&quot;containerPort&quot;</span><span class="token operator">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>
            <span class="token property">&quot;hostPort&quot;</span><span class="token operator">:</span> <span class="token number">31000</span><span class="token punctuation">,</span>
            <span class="token property">&quot;servicePort&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
            <span class="token property">&quot;protocol&quot;</span><span class="token operator">:</span> <span class="token string">&quot;tcp&quot;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">&quot;privileged&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token property">&quot;parameters&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">&quot;forcePullImage&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该任务启动一个 <code>python:3</code> 容器，执行 <code>python3 -m http.server 8080</code> 命令，作为一个简单的 web 服务，实际端口会映射到宿主机的 31000 端口。</p> <p>注意区分 hostPort 和 servicePort，前者代表任务映射到的本地可用端口（可用范围由 Mesos slave 汇报，默认为 31000 ~ 32000）；后者作为服务管理的端口，可以被用作一些服务发行机制使用进行转发，在整个 Marathon 集群中是唯一的。</p> <p>任务执行后，也可以在对应 slave 节点上通过 Docker 命令查看容器运行情况，容器将以 <code>mesos-SLAVE_ID</code>开头。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
1226b4ec8d7d        python:3            &quot;/bin/sh -c 'python3 &quot;   3 days ago          Up 3 days           0.0.0.0:10000-&gt;8080/tcp   mesos-06db0fba-49dc-4d28-ad87-6c2d5a020866-S10.b581149e-2c43-46a2-b652-1a0bc10204b3
</code></pre></div><h2 id="原理与架构"><a href="#原理与架构" aria-hidden="true" class="header-anchor">#</a> 原理与架构</h2> <p>首先，再次需要强调 Mesos 自身只是一个资源调度框架，并非一整套完整的应用管理平台，所以只有 Mesos 自己是不能干活的。但是基于 Mesos，可以比较容易地为各种应用管理框架或者中间件平台（作为 Mesos 的应用）提供分布式运行能力；同时多个框架也可以同时运行在一个 Mesos 集群中，提高整体的资源使用效率。</p> <p>Mesos 对自己定位范围的划分，使得它要完成的任务很明确，其它任务框架也可以很容易的与它进行整合。</p> <h3 id="架构"><a href="#架构" aria-hidden="true" class="header-anchor">#</a> 架构</h3> <p>下面这张基本架构图来自 Mesos 官方。</p> <p><img src="https://yeasy.gitbooks.io/docker_practice/mesos/_images/mesos-architecture.png" alt="mesos 的基本架构">图 1.22.3.1 - mesos 的基本架构</p> <p>可以看出，Mesos 采用了经典的主-从（master-slave）架构，其中主节点（管理节点）可以使用 zookeeper 来做 HA。</p> <p>Mesos master 服务将运行在主节点上，Mesos slave 服务则需要运行在各个计算任务节点上。</p> <p>负责完成具体任务的应用框架们，跟 Mesos master 进行交互，来申请资源。</p> <h3 id="基本单元"><a href="#基本单元" aria-hidden="true" class="header-anchor">#</a> 基本单元</h3> <p>Mesos 中有三个基本的组件：管理服务（master）、任务服务（slave）以及应用框架（framework）。</p> <h4 id="管理服务-master"><a href="#管理服务-master" aria-hidden="true" class="header-anchor">#</a> 管理服务 - master</h4> <p>跟大部分分布式系统中类似，主节点起到管理作用，将看到全局的信息，负责不同应用框架之间的资源调度和逻辑控制。应用框架需要注册到管理服务上才能被使用。</p> <p>用户和应用需要通过主节点提供的 API 来获取集群状态和操作集群资源。</p> <h4 id="任务服务-slave"><a href="#任务服务-slave" aria-hidden="true" class="header-anchor">#</a> 任务服务 - slave</h4> <p>负责汇报本从节点上的资源状态（空闲资源、运行状态等等）给主节点，并负责隔离本地资源来执行主节点分配的具体任务。</p> <p>隔离机制目前包括各种容器机制，包括 LXC、Docker 等。</p> <h4 id="应用框架-framework"><a href="#应用框架-framework" aria-hidden="true" class="header-anchor">#</a> 应用框架 - framework</h4> <p>应用框架是实际干活的，包括两个主要组件：</p> <ul><li>调度器（scheduler）：注册到主节点，等待分配资源；</li> <li>执行器（executor）：在从节点上执行框架指定的任务（框架也可以使用 Mesos 自带的执行器，包括 shell 脚本执行器和 Docker 执行器）。</li></ul> <p>应用框架可以分两种：一种是对资源的需求是会扩展的（比如 Hadoop、Spark 等），申请后还可能调整；一种是对资源需求大小是固定的（MPI 等），一次申请即可。</p> <h3 id="调度"><a href="#调度" aria-hidden="true" class="header-anchor">#</a> 调度</h3> <p>对于一个资源调度框架来说，最核心的就是调度机制，怎么能快速高效地完成对某个应用框架资源的分配，是核心竞争力所在。最理想情况下（大部分时候都无法实现），最好是能猜到应用们的实际需求，实现最大化的资源使用率。</p> <p>Mesos 为了实现尽量优化的调度，采取了两层（two-layer）的调度算法。</p> <h4 id="算法基本过程"><a href="#算法基本过程" aria-hidden="true" class="header-anchor">#</a> 算法基本过程</h4> <p>调度的基本思路很简单，master 先全局调度一大块资源给某个 framework，framework 自己再实现内部的细粒度调度，决定哪个任务用多少资源。两层调度简化了 Mesos master 自身的调度过程，通过将复杂的细粒度调度交由 framework 实现，避免了 Mesos master 成为性能瓶颈。</p> <p>调度机制支持插件机制来实现不同的策略。默认是 Dominant Resource Fairness（DRF）。</p> <p><em>注：DRF 算法细节可以参考论文《Dominant Resource Fairness: Fair Allocation of Multiple Resource Types》。其核心思想是对不同类型资源的多个请求，计算请求的主资源类型，然后根据主资源进行公平分配。</em></p> <h4 id="调度过程"><a href="#调度过程" aria-hidden="true" class="header-anchor">#</a> 调度过程</h4> <p>调度通过 offer 发送的方式进行交互。一个 offer 是一组资源，例如 <code>&lt;1 CPU, 2 GB Mem&gt;</code>。</p> <p>基本调度过程如下：</p> <ul><li>首先，slave 节点会周期性汇报自己可用的资源给 master；</li> <li>某个时候，master 收到应用框架发来的资源请求，根据调度策略，计算出来一个资源 offer 给 framework；</li> <li>framework 收到 offer 后可以决定要不要，如果接受的话，返回一个描述，说明自己希望如何使用和分配这些资源来运行某些任务（可以说明只希望使用部分资源，则多出来的会被 master 收回）；</li> <li>最后，master 则根据 framework 答复的具体分配情况发送给 slave，以使用 framework 的 executor 来按照分配的资源策略执行任务。</li></ul> <p>具体给出一个例子，某从节点向主节点汇报自己有 <code>&lt;4 CPU, 8 GB Mem&gt;</code> 的空闲资源，同时，主节点看到某个应用框架请求 <code>&lt;3 CPU, 6 GB Mem&gt;</code>，就创建一个 offer <code>&lt;slave#1, 4 CPU, 8 GB Mem&gt;</code> 把满足的资源发给应用框架。应用框架（的调度器）收到 offer 后觉得可以接受，就回复主节点，并告诉主节点希望运行两个任务：一个占用 <code>&lt;1 CPU, 2 GB Mem&gt;</code>，一个占用 一个占用 <code>&lt;2 CPU, 4 GB Mem&gt;</code>。主节点收到任务信息后分配任务到从节点上进行运行（实际上是应用框架的执行器来负责执行任务）。任务运行结束后资源可以被释放出来。</p> <p>剩余的资源还可以继续分配给其他应用框架或任务。</p> <p>应用框架在收到 offer 后，如果 offer 不满足自己的偏好（例如希望继续使用上次的 slave 节点），则可以选择拒绝 offer，等待 master 发送新的 offer 过来。另外，可以通过过滤器机制来加快资源的分配过程。</p> <h4 id="过滤器"><a href="#过滤器" aria-hidden="true" class="header-anchor">#</a> 过滤器</h4> <p>framework 可以通过过滤器机制告诉 master 它的资源偏好，比如希望分配过来的 offer 有哪个资源，或者至少有多少资源等。</p> <p>过滤器可以避免某些应用资源长期分配不到所需要的资源的情况，加速整个资源分配的交互过程。</p> <h4 id="回收机制"><a href="#回收机制" aria-hidden="true" class="header-anchor">#</a> 回收机制</h4> <p>为了避免某些任务长期占用集群中资源，Mesos 也支持回收机制。</p> <p>主节点可以定期回收计算节点上的任务所占用的资源，可以动态调整长期任务和短期任务的分布。</p> <h3 id="ha"><a href="#ha" aria-hidden="true" class="header-anchor">#</a> HA</h3> <p>从架构上看，最为核心的节点是 master 节点。除了使用 ZooKeeper 来解决单点失效问题之外，Mesos 的 master 节点自身还提供了很高的鲁棒性。</p> <p>Mesos master 节点在重启后，可以动态通过 slave 和 framework 发来的消息重建内部状态，虽然可能导致一定的时延，但这避免了传统控制节点对数据库的依赖。</p> <p>当然，为了减少 master 节点的负载过大，在集群中 slave 节点数目较多的时候，要避免把各种通知的周期配置的过短。实践中，可以通过部署多个 Mesos 集群来保持单个集群的规模不要过大。</p> <h2 id="mesos-配置项解析"><a href="#mesos-配置项解析" aria-hidden="true" class="header-anchor">#</a> Mesos 配置项解析</h2> <p>Mesos 支持在运行时通过命令行参数形式提供的配置项。如果是通过系统服务方式启动，也支持以配置文件或环境变量方式给出。当然，实际上最终是提取为命令行参数传递给启动命令。</p> <p>Mesos 的配置项分为三种类型：通用项（master 和 slave 都支持），只有 master 支持的，以及只有 slave 支持的。</p> <p>Mesos 配置项比较多，下面对一些重点配置进行描述。少数为必备项，意味着必须给出配置值；另外一些是可选配置，自己带有默认值。</p> <h3 id="通用项"><a href="#通用项" aria-hidden="true" class="header-anchor">#</a> 通用项</h3> <p>通用项数量不多，主要涉及到服务绑定地址和日志信息等，包括：</p> <ul><li><code>--advertise_ip=VALUE</code> 可以通过该地址访问到服务，比如应用框架访问到 master 节点；</li> <li><code>--advertise_port=VALUE</code> 可以通过该端口访问到服务；</li> <li><code>--external_log_file=VALUE</code> 指定存储日志的外部文件，可通过 Web 界面查看；</li> <li><code>--firewall_rules=VALUE</code> endpoint 防火墙规则，<code>VALUE</code> 可以是 JSON 格式或者存有 JSON 格式的文件路径；</li> <li><code>--ip=VALUE</code> 服务绑定到的IP 地址，用来监听外面过来的请求；</li> <li><code>--log_dir=VALUE</code> 日志文件路径，如果为空（默认值）则不存储日志到本地；</li> <li><code>--logbufsecs=VALUE</code> buffer 多少秒的日志，然后写入本地；</li> <li><code>--logging_level=VALUE</code> 日志记录的最低级别；</li> <li><code>--port=VALUE</code> 绑定监听的端口，master 默认是 5050，slave 默认是 5051。</li></ul> <h3 id="master-专属配置项"><a href="#master-专属配置项" aria-hidden="true" class="header-anchor">#</a> master 专属配置项</h3> <p>这些配置项是针对主节点上的 Mesos master 服务的，围绕高可用、注册信息、对应用框架的资源管理等。用户应该根据本地主节点资源情况来合理的配置这些选项。</p> <p>用户可以通过 <code>mesos-master --help</code> 命令来获取所有支持的配置项信息。</p> <p>必须指定的配置项有三个：</p> <ul><li><code>--quorum=VALUE</code> 必备项，使用基于 replicated-Log 的注册表（即利用 ZooKeeper 实现 HA）时，参与投票时的最少节点个数；</li> <li><code>--work_dir=VALUE</code> 必备项，注册表持久化信息存储位置；</li> <li><code>--zk=VALUE</code> 如果主节点为 HA 模式，此为必备项，指定 ZooKeepr 的服务地址，支持多个地址，之间用逗号隔离，例如 <code>zk://username:password@host1:port1,host2:port2,.../path</code>。还可以为存有路径信息的文件路径。</li></ul> <p>可选的配置项有：</p> <ul><li><code>--acls=VALUE</code> ACL 规则或所在文件；</li> <li><code>--allocation_interval=VALUE</code> 执行 allocation 的间隔，默认为 1sec；</li> <li><code>--allocator=VALUE</code> 分配机制，默认为 HierarchicalDRF；</li> <li><code>--[no-]authenticate</code> 是否允许非认证过的 framework 注册；</li> <li><code>--[no-]authenticate_slaves</code> 是否允许非认证过的 slaves 注册；</li> <li><code>--authenticators=VALUE</code> 对 framework 或 salves 进行认证时的实现机制；</li> <li><code>--cluster=VALUE</code> 集群别名，显示在 Web 界面上供用户识别的；</li> <li><code>--credentials=VALUE</code> 存储加密后凭证的文件的路径；</li> <li><code>--external_log_file=VALUE</code> 采用外部的日志文件；</li> <li><code>--framework_sorter=VALUE</code> 给定 framework 之间的资源分配策略；</li> <li><code>--hooks=VALUE</code> master 中安装的 hook 模块；</li> <li><code>--hostname=VALUE</code> master 节点使用的主机名，不配置则从系统中获取；</li> <li><code>--[no-]log_auto_initialize</code> 是否自动初始化注册表需要的 replicated 日志；</li> <li><code>--modules=VALUE</code> 要加载的模块，支持文件路径或者 JSON；</li> <li><code>--offer_timeout=VALUE</code> offer 撤销的超时；</li> <li><code>--rate_limits=VALUE</code> framework 的速率限制，即 query per second (qps)；</li> <li><code>--recovery_slave_removal_limit=VALUE</code> 限制注册表恢复后可以移除或停止的 slave 数目，超出后 master 会失败，默认是 100%；</li> <li><code>--slave_removal_rate_limit=VALUE slave</code> 没有完成健康度检查时候被移除的速率上限，例如 1/10mins 代表每十分钟最多有一个；</li> <li><code>--registry=VALUE</code> 注册表信息的持久化策略，默认为 <code>replicated_log</code> 存放本地，还可以为 <code>in_memory</code> 放在内存中；</li> <li><code>--registry_fetch_timeout=VALUE</code> 访问注册表失败超时；</li> <li><code>--registry_store_timeout=VALUE</code> 存储注册表失败超时；</li> <li><code>--[no-]registry_strict</code> 是否按照注册表中持久化信息执行操作，默认为 false；</li> <li><code>--roles=VALUE</code> 集群中 framework 可以所属的分配角色；</li> <li><code>--[no-]root_submissions</code> root 是否可以提交 framework，默认为 true；</li> <li><code>--slave_reregister_timeout=VALUE</code> 新的 lead master 节点选举出来后，多久之内所有的 slave 需要注册，超时的 salve 将被移除并关闭，默认为 10mins；</li> <li><code>--user_sorter=VALUE</code> 在用户之间分配资源的策略，默认为 drf；</li> <li><code>--webui_dir=VALUE</code> webui 实现的文件目录所在，默认为 <code>/usr/local/share/mesos/webui</code>；</li> <li><code>--weights=VALUE</code> 各个角色的权重；</li> <li><code>--whitelist=VALUE</code> 文件路径，包括发送 offer 的 slave 名单，默认为 None；</li> <li><code>--zk_session_timeout=VALUE</code> session 超时，默认为 10secs；</li> <li><code>--max_executors_per_slave=VALUE</code> 配置了 <code>--with-network-isolator</code> 时可用，限制每个 slave 同时执行任务个数。</li></ul> <p>下面给出一个由三个节点组成的 master 集群典型配置，工作目录指定为 <code>/tmp/mesos</code>，集群名称为 <code>mesos_cluster</code>。</p> <div class="language-sh extra-class"><pre class="language-text"><code>mesos-master \
--zk=zk://10.0.0.2:2181,10.0.0.3:2181,10.0.0.4:2181/mesos \
--quorum=2 \
--work_dir=/tmp/mesos \
--cluster=mesos_cluster
</code></pre></div><h3 id="slave-专属配置项"><a href="#slave-专属配置项" aria-hidden="true" class="header-anchor">#</a> slave 专属配置项</h3> <p>slave 节点支持的配置项是最多的，因为它所完成的事情也最复杂。这些配置项既包括跟主节点打交道的一些参数，也包括对本地资源的配置，包括隔离机制、本地任务的资源限制等。</p> <p>用户可以通过 <code>mesos-slave --help</code> 命令来获取所有支持的配置项信息。</p> <p>必备项就一个：</p> <ul><li><code>--master=VALUE</code> 必备项，master 所在地址，或对应 ZooKeeper 服务地址，或文件路径，可以是列表。</li></ul> <p>以下为可选配置项：</p> <ul><li><code>--attributes=VALUE</code> 机器属性；</li> <li><code>--authenticatee=VALUE</code> 跟 master 进行认证时候的认证机制；</li> <li><code>--[no-]cgroups_enable_cfs</code> 采用 CFS 进行带宽限制时候对 CPU 资源进行限制，默认为 false；</li> <li><code>--cgroups_hierarchy=VALUE</code> cgroups 的目录根位置，默认为 <code>/sys/fs/cgroup</code>；</li> <li><code>--[no-]cgroups_limit_swap</code> 限制内存和 swap，默认为 false，只限制内存；</li> <li><code>--cgroups_root=VALUE</code> 根 cgroups 的名称，默认为 mesos；</li> <li><code>--container_disk_watch_interval=VALUE</code> 为容器进行硬盘配额查询的时间间隔；</li> <li><code>--containerizer_path=VALUE</code> 采用外部隔离机制（<code>--isolation=external</code>）时候，外部容器机制执行文件路径；</li> <li><code>--containerizers=VALUE</code> 可用的容器实现机制，包括 mesos、external、docker；</li> <li><code>--credential=VALUE</code> 加密后凭证，或者所在文件路径；</li> <li><code>--default_container_image=VALUE</code> 采用外部容器机制时，任务缺省使用的镜像；</li> <li><code>--default_container_info=VALUE</code> 容器信息的缺省值；</li> <li><code>--default_role=VALUE</code> 资源缺省分配的角色；</li> <li><code>--disk_watch_interval=VALUE</code> 硬盘使用情况的周期性检查间隔，默认为 1mins；</li> <li><code>--docker=VALUE</code> docker 执行文件的路径；</li> <li><code>--docker_remove_delay=VALUE</code> 删除容器之前的等待时间，默认为 6hrs；</li> <li><code>--[no-]docker_kill_orphans</code> 清除孤儿容器，默认为 true；</li> <li><code>--docker_sock=VALUE</code> docker sock 地址，默认为 <code>/var/run/docker.sock</code>；</li> <li><code>--docker_mesos_image=VALUE</code> 运行 slave 的 docker 镜像，如果被配置，docker 会假定 slave 运行在一个 docker 容器里；</li> <li><code>--docker_sandbox_directory=VALUE</code> sandbox 映射到容器里的哪个路径；</li> <li><code>--docker_stop_timeout=VALUE</code> 停止实例后等待多久执行 kill 操作，默认为 0secs；</li> <li><code>--[no-]enforce_container_disk_quota</code> 是否启用容器配额限制，默认为 false；</li> <li><code>--executor_registration_timeout=VALUE</code> 执行应用最多可以等多久再注册到 slave，否则停止它，默认为 1mins；</li> <li><code>--executor_shutdown_grace_period=VALUE</code> 执行应用停止后，等待多久，默认为 5secs；</li> <li><code>--external_log_file=VALUE</code> 外部日志文件；</li> <li><code>--fetcher_cache_size=VALUE</code> fetcher 的 cache 大小，默认为 2 GB；</li> <li><code>--fetcher_cache_dir=VALUE</code> fetcher cache 文件存放目录，默认为 /tmp/mesos/fetch；</li> <li><code>--frameworks_home=VALUE</code> 执行应用前添加的相对路径，默认为空；</li> <li><code>--gc_delay=VALUE</code> 多久清理一次执行应用目录，默认为 1weeks；</li> <li><code>--gc_disk_headroom=VALUE</code> 调整计算最大执行应用目录年龄的硬盘留空量，默认为 0.1；</li> <li><code>--hadoop_home=VALUE</code> hadoop 安装目录，默认为空，会自动查找 HADOOP_HOME 或者从系统路径中查找；</li> <li><code>--hooks=VALUE</code> 安装在 master 中的 hook 模块列表；</li> <li><code>--hostname=VALUE</code> slave 节点使用的主机名；</li> <li><code>--isolation=VALUE</code> 隔离机制，例如 <code>posix/cpu,posix/mem</code>（默认）或者 <code>cgroups/cpu,cgroups/mem</code>、<code>external</code> 等；</li> <li><code>--launcher_dir=VALUE</code> mesos 可执行文件的路径，默认为 <code>/usr/local/lib/mesos</code>；</li> <li><code>--image_providers=VALUE</code> 支持的容器镜像机制，例如 'APPC,DOCKER'；</li> <li><code>--oversubscribed_resources_interval=VALUE</code> slave 节点定期汇报超配资源状态的周期；</li> <li><code>--modules=VALUE</code> 要加载的模块，支持文件路径或者 JSON；</li> <li><code>--perf_duration=VALUE</code> perf 采样时长，必须小于 perf_interval，默认为 10secs；</li> <li><code>--perf_events=VALUE</code> perf 采样的事件；</li> <li><code>--perf_interval=VALUE</code> perf 采样的时间间隔；</li> <li><code>--qos_controller=VALUE</code> 超配机制中保障 QoS 的控制器名；</li> <li><code>--qos_correction_interval_min=VALUE</code> Qos 控制器纠正超配资源的最小间隔，默认为 0secs；</li> <li><code>--recover=VALUE</code> 回复后是否重连旧的执行应用，reconnect（默认值）是重连，cleanup 清除旧的执行器并退出；</li> <li><code>--recovery_timeout=VALUE</code> slave 恢复时的超时，太久则所有相关的执行应用将自行退出，默认为 15mins；</li> <li><code>--registration_backoff_factor=VALUE</code> 跟 master 进行注册时候的重试时间间隔算法的因子，默认为 1secs，采用随机指数算法，最长 1mins；</li> <li><code>--resource_monitoring_interval=VALUE</code> 周期性监测执行应用资源使用情况的间隔，默认为 1secs；</li> <li><code>--resources=VALUE</code> 每个 slave 可用的资源，比如主机端口默认为 [31000, 32000]；</li> <li><code>--[no-]revocable_cpu_low_priority</code> 运行在可撤销 CPU 上容器将拥有较低优先级，默认为 true。</li> <li><code>--slave_subsystems=VALUE</code> slave 运行在哪些 cgroup 子系统中，包括 memory，cpuacct 等，缺省为空；</li> <li><code>--[no-]strict</code> 是否认为所有错误都不可忽略，默认为 true；</li> <li><code>--[no-]switch_user</code> 用提交任务的用户身份来运行，默认为 true；</li> <li><code>--work_dir=VALUE</code> framework 的工作目录，默认为 /tmp/mesos。</li></ul> <p>下面这些选项需要配置 <code>--with-network-isolator</code> 一起使用（编译时需要启用 <code>--with-network-isolator</code>参数）。</p> <ul><li><code>--ephemeral_ports_per_container=VALUE</code> 分配给一个容器的临时端口的最大数目，需要为 2 的整数幂（默认为 1024）；</li> <li><code>--eth0_name=VALUE</code> public 网络的接口名称，如果不指定，根据主机路由进行猜测；</li> <li><code>--lo_name=VALUE</code> loopback 网卡名称；</li> <li><code>--egress_rate_limit_per_container=VALUE</code> 每个容器的输出流量限制速率限制（采用 fq_codel 算法来限速），单位是字节每秒；</li> <li><code>--[no-]-egress_unique_flow_per_container</code> 是否把不同容器的流量当作彼此不同的流，避免彼此影响（默认为 false）；</li> <li><code>--[no-]network_enable_socket_statistics</code> 是否采集每个容器的 socket 统计信息，默认为 false。</li></ul> <p>下面给出一个典型的 slave 配置，容器为 Docker，监听在 <code>10.0.0.10</code> 地址；节点上限制 16 个 CPU、64 GB 内存，容器的非临时端口范围指定为 [31000-32000]，临时端口范围指定为 [32768-57344]；每个容器临时端口最多为 512 个，并且外出流量限速为 50 MB/s。</p> <div class="language-sh extra-class"><pre class="language-text"><code>mesos-slave \
--master=zk://10.0.0.2:2181,10.0.0.3:2181,10.0.0.4:2181/mesos \
--containerizers=docker \
--ip=10.0.0.10 \
--isolation=cgroups/cpu,cgroups/mem,network/port_mapping \
--resources=cpus:16;mem:64000;ports:[31000-32000];ephemeral_ports:[32768-57344] \
--ephemeral_ports_per_container=512 \
--egress_rate_limit_per_container=50000KB \
--egress_unique_flow_per_container
</code></pre></div><p>为了避免主机分配的临时端口跟我们指定的临时端口范围冲突，需要在主机节点上进行配置。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ echo &quot;57345 61000&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range
</code></pre></div><p><em>注：非临时端口是 Mesos 分配给框架，绑定到任务使用的，端口号往往有明确意义；临时端口是系统分配的，往往不太关心具体端口号。</em></p> <h2 id="日志与监控"><a href="#日志与监控" aria-hidden="true" class="header-anchor">#</a> 日志与监控</h2> <p>Mesos 自身提供了强大的日志和监控功能，某些应用框架也提供了针对框架中任务的监控能力。通过这些接口，用户可以实时获知集群的各种状态。</p> <h3 id="日志配置"><a href="#日志配置" aria-hidden="true" class="header-anchor">#</a> 日志配置</h3> <p>日志文件默认在 <code>/var/log/mesos</code> 目录下，根据日志等级带有不同后缀。</p> <p>用户可以通过日志来调试使用中碰到的问题。</p> <p>一般的，推荐使用 <code>--log_dir</code> 选项来指定日志存放路径，并通过日志分析引擎来进行监控。</p> <h3 id="监控"><a href="#监控" aria-hidden="true" class="header-anchor">#</a> 监控</h3> <p>Mesos 提供了方便的监控接口，供用户查看集群中各个节点的状态。</p> <h4 id="主节点-2"><a href="#主节点-2" aria-hidden="true" class="header-anchor">#</a> 主节点</h4> <p>通过 <code>http://MASTER_NODE:5050/metrics/snapshot</code> 地址可以获取到 Mesos 主节点的各种状态统计信息，包括资源（CPU、硬盘、内存）使用、系统状态、从节点、应用框架、任务状态等。</p> <p>例如查看主节点 <code>10.0.0.2</code> 的状态信息，并用 jq 来解析返回的 json 对象。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ curl -s http://10.0.0.2:5050/metrics/snapshot |jq .
{
  &quot;system/mem_total_bytes&quot;: 4144713728,
  &quot;system/mem_free_bytes&quot;: 153071616,
  &quot;system/load_5min&quot;: 0.37,
  &quot;system/load_1min&quot;: 0.6,
  &quot;system/load_15min&quot;: 0.29,
  &quot;system/cpus_total&quot;: 4,
  &quot;registrar/state_store_ms/p9999&quot;: 45.4096616192,
  &quot;registrar/state_store_ms/p999&quot;: 45.399272192,
  &quot;registrar/state_store_ms/p99&quot;: 45.29537792,
  &quot;registrar/state_store_ms/p95&quot;: 44.8336256,
  &quot;registrar/state_store_ms/p90&quot;: 44.2564352,
  &quot;registrar/state_store_ms/p50&quot;: 34.362368,
  ...
  &quot;master/recovery_slave_removals&quot;: 1,
  &quot;master/slave_registrations&quot;: 0,
  &quot;master/slave_removals&quot;: 0,
  &quot;master/slave_removals/reason_registered&quot;: 0,
  &quot;master/slave_removals/reason_unhealthy&quot;: 0,
  &quot;master/slave_removals/reason_unregistered&quot;: 0,
  &quot;master/slave_reregistrations&quot;: 2,
  &quot;master/slave_shutdowns_canceled&quot;: 0,
  &quot;master/slave_shutdowns_completed&quot;: 1,
  &quot;master/slave_shutdowns_scheduled&quot;: 1
}
</code></pre></div><h4 id="从节点-2"><a href="#从节点-2" aria-hidden="true" class="header-anchor">#</a> 从节点</h4> <p>通过 <code>http://SLAVE_NODE:5051/metrics/snapshot</code> 地址可以获取到 Mesos 从节点的各种状态统计信息，包括资源、系统状态、各种消息状态等。</p> <p>例如查看从节点 <code>10.0.0.10</code> 的状态信息。</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ curl -s http://10.0.0.10:5051/metrics/snapshot |jq .
{
  &quot;system/mem_total_bytes&quot;: 16827785216,
  &quot;system/mem_free_bytes&quot;: 3377315840,
  &quot;system/load_5min&quot;: 0.11,
  &quot;system/load_1min&quot;: 0.16,
  &quot;system/load_15min&quot;: 0.13,
  &quot;system/cpus_total&quot;: 8,
  &quot;slave/valid_status_updates&quot;: 11,
  &quot;slave/valid_framework_messages&quot;: 0,
  &quot;slave/uptime_secs&quot;: 954125.458927872,
  &quot;slave/tasks_starting&quot;: 0,
  &quot;slave/tasks_staging&quot;: 0,
  &quot;slave/tasks_running&quot;: 1,
  &quot;slave/tasks_lost&quot;: 0,
  &quot;slave/tasks_killed&quot;: 2,
  &quot;slave/tasks_finished&quot;: 0,
  &quot;slave/executors_preempted&quot;: 0,
  &quot;slave/executor_directory_max_allowed_age_secs&quot;: 403050.709525191,
  &quot;slave/disk_used&quot;: 0,
  &quot;slave/disk_total&quot;: 88929,
  &quot;slave/disk_revocable_used&quot;: 0,
  &quot;slave/disk_revocable_total&quot;: 0,
  &quot;slave/disk_revocable_percent&quot;: 0,
  &quot;slave/disk_percent&quot;: 0,
  &quot;containerizer/mesos/container_destroy_errors&quot;: 0,
  &quot;slave/container_launch_errors&quot;: 6,
  &quot;slave/cpus_percent&quot;: 0.025,
  &quot;slave/cpus_revocable_percent&quot;: 0,
  &quot;slave/cpus_revocable_total&quot;: 0,
  &quot;slave/cpus_revocable_used&quot;: 0,
  &quot;slave/cpus_total&quot;: 8,
  &quot;slave/cpus_used&quot;: 0.2,
  &quot;slave/executors_registering&quot;: 0,
  &quot;slave/executors_running&quot;: 1,
  &quot;slave/executors_terminated&quot;: 8,
  &quot;slave/executors_terminating&quot;: 0,
  &quot;slave/frameworks_active&quot;: 1,
  &quot;slave/invalid_framework_messages&quot;: 0,
  &quot;slave/invalid_status_updates&quot;: 0,
  &quot;slave/mem_percent&quot;: 0.00279552715654952,
  &quot;slave/mem_revocable_percent&quot;: 0,
  &quot;slave/mem_revocable_total&quot;: 0,
  &quot;slave/mem_revocable_used&quot;: 0,
  &quot;slave/mem_total&quot;: 15024,
  &quot;slave/mem_used&quot;: 42,
  &quot;slave/recovery_errors&quot;: 0,
  &quot;slave/registered&quot;: 1,
  &quot;slave/tasks_failed&quot;: 6
}
</code></pre></div><p>另外，通过 <code>http://MASTER_NODE:5050/monitor/statistics.json</code> 地址可以看到该从节点上容器网络相关的统计数据，包括进出流量、丢包数、队列情况等。获取方法同上，在此不再演示。</p> <h2 id="常见应用框架"><a href="#常见应用框架" aria-hidden="true" class="header-anchor">#</a> 常见应用框架</h2> <p>应用框架是实际干活的，可以理解为 Mesos 之上跑的 <code>应用</code>。应用框架注册到 Mesos master 服务上即可使用。</p> <p>用户大部分时候，只需要跟应用框架打交道。因此，选择合适的应用框架十分关键。</p> <p>Mesos 目前支持的应用框架分为四大类：长期运行任务（以及 PaaS）、大数据处理、批量调度、数据存储。</p> <p>随着 Mesos 自身的发展，越来越多的框架开始支持 Mesos，下面总结了目前常用的一些框架。</p> <h3 id="长期运行的服务"><a href="#长期运行的服务" aria-hidden="true" class="header-anchor">#</a> 长期运行的服务</h3> <h4 id="aurora"><a href="#aurora" aria-hidden="true" class="header-anchor">#</a> <a href="http://aurora.incubator.apache.org/" target="_blank" rel="noopener noreferrer">Aurora<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>利用 Mesos 调度安排的任务，保证任务一直在运行。</p> <p>提供 REST 接口，客户端和 webUI（8081 端口）</p> <h4 id="marathon-2"><a href="#marathon-2" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/mesosphere/marathon" target="_blank" rel="noopener noreferrer">Marathon<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>一个私有 PaaS 平台，保证运行的应用不被中断。</p> <p>如果任务停止了，会自动重启一个新的相同任务。</p> <p>支持任务为任意 bash 命令，以及容器。</p> <p>提供 REST 接口，客户端和 webUI（8080 端口）</p> <h4 id="singularity"><a href="#singularity" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/HubSpot/Singularity" target="_blank" rel="noopener noreferrer">Singularity<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>一个私有 PaaS 平台。</p> <p>调度器，运行长期的任务和一次性任务。</p> <p>提供 REST 接口，客户端和 webUI（7099、8080 端口），支持容器。</p> <h3 id="大数据处理"><a href="#大数据处理" aria-hidden="true" class="header-anchor">#</a> 大数据处理</h3> <h4 id="cray-chapel"><a href="#cray-chapel" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/nqn/mesos-chapel" target="_blank" rel="noopener noreferrer">Cray Chapel<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>支持 Chapel 并行编程语言的运行框架。</p> <h4 id="dpark"><a href="#dpark" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/douban/dpark" target="_blank" rel="noopener noreferrer">Dpark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>Spark 的 Python 实现。</p> <h4 id="hadoop"><a href="#hadoop" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/mesos/hadoop" target="_blank" rel="noopener noreferrer">Hadoop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>经典的 map-reduce 模型的实现。</p> <h4 id="spark"><a href="#spark" aria-hidden="true" class="header-anchor">#</a> <a href="http://spark.apache.org/" target="_blank" rel="noopener noreferrer">Spark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>跟 Hadoop 类似，但处理迭代类型任务会更好的使用内存做中间状态缓存，速度要快一些。</p> <h4 id="storm"><a href="#storm" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/mesos/storm" target="_blank" rel="noopener noreferrer">Storm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>分布式流计算，可以实时处理数据流。</p> <h3 id="批量调度"><a href="#批量调度" aria-hidden="true" class="header-anchor">#</a> 批量调度</h3> <h4 id="chronos"><a href="#chronos" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/airbnb/chronos" target="_blank" rel="noopener noreferrer">Chronos<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>Cron 的分布式实现，负责任务调度，支持容错。</p> <h4 id="jenkins"><a href="#jenkins" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/jenkinsci/mesos-plugin" target="_blank" rel="noopener noreferrer">Jenkins<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>大名鼎鼎的 CI 引擎。使用 mesos-jenkins 插件，可以将 jenkins 的任务被 Mesos 集群来动态调度执行。</p> <h4 id="jobserver"><a href="#jobserver" aria-hidden="true" class="header-anchor">#</a> <a href="http://www.grandlogic.com/content/html_docs/jobserver.html" target="_blank" rel="noopener noreferrer">JobServer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>基于 Java 的调度任务和数据处理引擎。</p> <h4 id="godocker"><a href="#godocker" aria-hidden="true" class="header-anchor">#</a> <a href="https://bitbucket.org/osallou/go-docker" target="_blank" rel="noopener noreferrer">GoDocker<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>基于 Docker 容器的集群维护工具。提供用户接口，除了支持 Mesos，还支持 Kubernetes、Swarm 等。</p> <h3 id="数据存储"><a href="#数据存储" aria-hidden="true" class="header-anchor">#</a> 数据存储</h3> <h4 id="elasticsearch"><a href="#elasticsearch" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/mesos/elasticsearch" target="_blank" rel="noopener noreferrer">ElasticSearch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>功能十分强大的分布式数据搜索引擎。</p> <p>一方面通过分布式集群实现可靠的数据库，一方面提供灵活的 API，对数据进行整合和分析。ElasticSearch + LogStash + Kibana 目前合成为 ELK 工具栈。</p> <h4 id="hypertable"><a href="#hypertable" aria-hidden="true" class="header-anchor">#</a> <a href="https://code.google.com/p/hypertable" target="_blank" rel="noopener noreferrer">Hypertable<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>高性能的分布式数据库，支持结构化或者非结构化的数据存储。</p> <h4 id="tachyon"><a href="#tachyon" aria-hidden="true" class="header-anchor">#</a> <a href="http://tachyon-project.org/" target="_blank" rel="noopener noreferrer">Tachyon<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <p>内存为中心的分布式存储系统，利用内存访问的高速提供高性能。</p> <p>数据存储</p> <h3 id="本章小结"><a href="#本章小结" aria-hidden="true" class="header-anchor">#</a> 本章小结</h3> <p>本章讲解了 Mesos 的安装使用、基本原理和架构，以及支持 Mesos 的重要应用框架。Mesos 最初设计为资源调度器，然而其灵活的设计和对上层框架的优秀支持，使得它可以很好的支持大规模的分布式应用场景。结合 Docker，Mesos 可以很容易部署一套私有的容器云。</p> <p>除了核心功能之外，Mesos 在设计上有许多值得借鉴之处，比如它清晰的定位、简洁的架构、细致的参数、高度容错的可靠，还有对限速、监控等的支持等。</p> <p>Mesos 作为一套成熟的开源项目，可以很好的被应用和集成到生产环境中。但它的定位集中在资源调度，往往需要结合应用框架或二次开发。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/cloud/Docker/kubernetes.html" class="prev">
          Kubernetes
        </a></span> <span class="next"><a href="/cloud/Docker/cases_os.html">
          实战-操作系统
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.365f7fea.js" defer></script><script src="/assets/js/46.6247d916.js" defer></script>
  </body>
</html>
